/* automatically generated by rust-bindgen */

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
pub mod PacketPriority {
    #[doc = " These enumerations are used to describe when packets are delivered."]
    pub type Type = i32;
    #[doc = " The highest possible priority. These message trigger sends immediately, and are generally not buffered or aggregated into a single datagram."]
    pub const IMMEDIATE_PRIORITY: Type = 0;
    #[doc = " For every 2 IMMEDIATE_PRIORITY messages, 1 HIGH_PRIORITY will be sent."]
    #[doc = " Messages at this priority and lower are buffered to be sent in groups at 10 millisecond intervals to reduce UDP overhead and better measure congestion control."]
    pub const HIGH_PRIORITY: Type = 1;
    #[doc = " For every 2 HIGH_PRIORITY messages, 1 MEDIUM_PRIORITY will be sent."]
    #[doc = " Messages at this priority and lower are buffered to be sent in groups at 10 millisecond intervals to reduce UDP overhead and better measure congestion control."]
    pub const MEDIUM_PRIORITY: Type = 2;
    #[doc = " For every 2 MEDIUM_PRIORITY messages, 1 LOW_PRIORITY will be sent."]
    #[doc = " Messages at this priority and lower are buffered to be sent in groups at 10 millisecond intervals to reduce UDP overhead and better measure congestion control."]
    pub const LOW_PRIORITY: Type = 3;
    #[doc = " \\internal"]
    pub const NUMBER_OF_PRIORITIES: Type = 4;
}
pub mod PacketReliability {
    #[doc = " These enumerations are used to describe how packets are delivered."]
    #[doc = " \\note  Note to self: I write this with 3 bits in the stream.  If I add more remember to change that"]
    #[doc = " \\note In ReliabilityLayer::WriteToBitStreamFromInternalPacket I assume there are 5 major types"]
    #[doc = " \\note Do not reorder, I check on >= UNRELIABLE_WITH_ACK_RECEIPT"]
    pub type Type = i32;
    #[doc = " Same as regular UDP, except that it will also discard duplicate datagrams.  RakNet adds (6 to 17) + 21 bits of overhead, 16 of which is used to detect duplicate packets and 6 to 17 of which is used for message length."]
    pub const UNRELIABLE: Type = 0;
    #[doc = " Regular UDP with a sequence counter.  Out of order messages will be discarded."]
    #[doc = " Sequenced and ordered messages sent on the same channel will arrive in the order sent."]
    pub const UNRELIABLE_SEQUENCED: Type = 1;
    #[doc = " The message is sent reliably, but not necessarily in any order.  Same overhead as UNRELIABLE."]
    pub const RELIABLE: Type = 2;
    #[doc = " This message is reliable and will arrive in the order you sent it.  Messages will be delayed while waiting for out of order messages.  Same overhead as UNRELIABLE_SEQUENCED."]
    #[doc = " Sequenced and ordered messages sent on the same channel will arrive in the order sent."]
    pub const RELIABLE_ORDERED: Type = 3;
    #[doc = " This message is reliable and will arrive in the sequence you sent it.  Out or order messages will be dropped.  Same overhead as UNRELIABLE_SEQUENCED."]
    #[doc = " Sequenced and ordered messages sent on the same channel will arrive in the order sent."]
    pub const RELIABLE_SEQUENCED: Type = 4;
    #[doc = " Same as UNRELIABLE, however the user will get either ID_SND_RECEIPT_ACKED or ID_SND_RECEIPT_LOSS based on the result of sending this message when calling RakPeerInterface::Receive(). Bytes 1-4 will contain the number returned from the Send() function. On disconnect or shutdown, all messages not previously acked should be considered lost."]
    pub const UNRELIABLE_WITH_ACK_RECEIPT: Type = 5;
    #[doc = " Same as RELIABLE. The user will also get ID_SND_RECEIPT_ACKED after the message is delivered when calling RakPeerInterface::Receive(). ID_SND_RECEIPT_ACKED is returned when the message arrives, not necessarily the order when it was sent. Bytes 1-4 will contain the number returned from the Send() function. On disconnect or shutdown, all messages not previously acked should be considered lost. This does not return ID_SND_RECEIPT_LOSS."]
    pub const RELIABLE_WITH_ACK_RECEIPT: Type = 6;
    #[doc = " Same as RELIABLE_ORDERED_ACK_RECEIPT. The user will also get ID_SND_RECEIPT_ACKED after the message is delivered when calling RakPeerInterface::Receive(). ID_SND_RECEIPT_ACKED is returned when the message arrives, not necessarily the order when it was sent. Bytes 1-4 will contain the number returned from the Send() function. On disconnect or shutdown, all messages not previously acked should be considered lost. This does not return ID_SND_RECEIPT_LOSS."]
    pub const RELIABLE_ORDERED_WITH_ACK_RECEIPT: Type = 7;
    #[doc = " \\internal"]
    pub const NUMBER_OF_RELIABILITIES: Type = 8;
}
pub type Time = u64;
pub type TimeMS = u32;
pub type TimeUS = u64;
pub mod StartupResult {
    pub type Type = i32;
    pub const RAKNET_STARTED: Type = 0;
    pub const RAKNET_ALREADY_STARTED: Type = 1;
    pub const INVALID_SOCKET_DESCRIPTORS: Type = 2;
    pub const INVALID_MAX_CONNECTIONS: Type = 3;
    pub const SOCKET_FAMILY_NOT_SUPPORTED: Type = 4;
    pub const SOCKET_PORT_ALREADY_IN_USE: Type = 5;
    pub const SOCKET_FAILED_TO_BIND: Type = 6;
    pub const SOCKET_FAILED_TEST_SEND: Type = 7;
    pub const PORT_CANNOT_BE_ZERO: Type = 8;
    pub const FAILED_TO_CREATE_NETWORK_THREAD: Type = 9;
    pub const COULD_NOT_GENERATE_GUID: Type = 10;
    pub const STARTUP_OTHER_FAILURE: Type = 11;
}
pub mod ConnectionAttemptResult {
    pub type Type = i32;
    pub const CONNECTION_ATTEMPT_STARTED: Type = 0;
    pub const INVALID_PARAMETER: Type = 1;
    pub const CANNOT_RESOLVE_DOMAIN_NAME: Type = 2;
    pub const ALREADY_CONNECTED_TO_ENDPOINT: Type = 3;
    pub const CONNECTION_ATTEMPT_ALREADY_IN_PROGRESS: Type = 4;
    pub const SECURITY_INITIALIZATION_FAILED: Type = 5;
}
pub mod ConnectionState {
    #[doc = " Returned from RakPeerInterface::GetConnectionState()"]
    pub type Type = i32;
    #[doc = " Connect() was called, but the process hasn't started yet"]
    pub const IS_PENDING: Type = 0;
    #[doc = " Processing the connection attempt"]
    pub const IS_CONNECTING: Type = 1;
    #[doc = " Is connected and able to communicate"]
    pub const IS_CONNECTED: Type = 2;
    #[doc = " Was connected, but will disconnect as soon as the remaining messages are delivered"]
    pub const IS_DISCONNECTING: Type = 3;
    #[doc = " A connection attempt failed and will be aborted"]
    pub const IS_SILENTLY_DISCONNECTING: Type = 4;
    #[doc = " No longer connected"]
    pub const IS_DISCONNECTED: Type = 5;
    #[doc = " Was never connected, or else was disconnected long enough ago that the entry has been discarded"]
    pub const IS_NOT_CONNECTED: Type = 6;
}
pub type SystemIndex = ::std::os::raw::c_ushort;
pub type BitSize_t = u32;
pub mod PublicKeyMode {
    #[doc = " Used with the PublicKey structure"]
    pub type Type = i32;
    #[doc = " The connection is insecure. You can also just pass 0 for the pointer to PublicKey in RakPeerInterface::Connect()"]
    pub const PKM_INSECURE_CONNECTION: Type = 0;
    #[doc = " Accept whatever public key the server gives us. This is vulnerable to man in the middle, but does not require"]
    #[doc = " distribution of the public key in advance of connecting."]
    pub const PKM_ACCEPT_ANY_PUBLIC_KEY: Type = 1;
    #[doc = " Use a known remote server public key. PublicKey::remoteServerPublicKey must be non-zero."]
    #[doc = " This is the recommended mode for secure connections."]
    pub const PKM_USE_KNOWN_PUBLIC_KEY: Type = 2;
    #[doc = " Use a known remote server public key AND provide a public key for the connecting client."]
    #[doc = " PublicKey::remoteServerPublicKey, myPublicKey and myPrivateKey must be all be non-zero."]
    #[doc = " The server must cooperate for this mode to work."]
    #[doc = " I recommend not using this mode except for server-to-server communication as it significantly increases the CPU requirements during connections for both sides."]
    #[doc = " Furthermore, when it is used, a connection password should be used as well to avoid DoS attacks."]
    pub const PKM_USE_TWO_WAY_AUTHENTICATION: Type = 3;
}
#[doc = " Passed to RakPeerInterface::Connect()"]
#[repr(C)]
#[derive(Debug)]
pub struct PublicKey {
    #[doc = " How to interpret the public key, see above"]
    pub publicKeyMode: PublicKeyMode::Type,
    #[doc = " Pointer to a public key of length cat::EasyHandshake::PUBLIC_KEY_BYTES. See the Encryption sample."]
    pub remoteServerPublicKey: *mut ::std::os::raw::c_char,
    #[doc = " (Optional) Pointer to a public key of length cat::EasyHandshake::PUBLIC_KEY_BYTES"]
    pub myPublicKey: *mut ::std::os::raw::c_char,
    #[doc = " (Optional) Pointer to a private key of length cat::EasyHandshake::PRIVATE_KEY_BYTES"]
    pub myPrivateKey: *mut ::std::os::raw::c_char,
}

#[doc = " Describes the local socket to use for RakPeer::Startup"]
#[repr(C)]
#[derive(Debug)]
pub struct SocketDescriptor {
    #[doc = " The local port to bind to.  Pass 0 to have the OS autoassign a port."]
    pub port: ::std::os::raw::c_ushort,
    #[doc = " The local network card address to bind to, such as \"127.0.0.1\".  Pass an empty string to use INADDR_ANY."]
    pub hostAddress: [::std::os::raw::c_char; 32usize],
    #[doc = " IP version: For IPV4, use AF_INET (default). For IPV6, use AF_INET6. To autoselect, use AF_UNSPEC."]
    #[doc = " IPV6 is the newer internet protocol. Instead of addresses such as natpunch.jenkinssoftware.com, you may have an address such as fe80::7c:31f7:fec4:27de%14."]
    #[doc = " Encoding takes 16 bytes instead of 4, so IPV6 is less efficient for bandwidth."]
    #[doc = " On the positive side, NAT Punchthrough is not needed and should not be used with IPV6 because there are enough addresses that routers do not need to create address mappings."]
    #[doc = " RakPeer::Startup() will fail if this IP version is not supported."]
    #[doc = " \\pre RAKNET_SUPPORT_IPV6 must be set to 1 in RakNetDefines.h for AF_INET6"]
    pub socketFamily: ::std::os::raw::c_short,
    pub remotePortRakNetWasStartedOn_PS3_PSP2: ::std::os::raw::c_ushort,
    pub chromeInstance: ::std::os::raw::c_int,
    pub blockingSocket: bool,
    #[doc = " XBOX only: set IPPROTO_VDP if you want to use VDP. If enabled, this socket does not support broadcast to 255.255.255.255"]
    pub extraSocketOptions: ::std::os::raw::c_uint,
}
extern "C" {
    #[link_name = "\u{1}??0SocketDescriptor@RakNet@@QEAA@XZ"]
    pub fn SocketDescriptor_SocketDescriptor(this: *mut SocketDescriptor);
}
extern "C" {
    #[link_name = "\u{1}??0SocketDescriptor@RakNet@@QEAA@GPEBD@Z"]
    pub fn SocketDescriptor_SocketDescriptor1(
        this: *mut SocketDescriptor,
        _port: ::std::os::raw::c_ushort,
        _hostAddress: *const ::std::os::raw::c_char,
    );
}
impl SocketDescriptor {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        SocketDescriptor_SocketDescriptor(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(
        _port: ::std::os::raw::c_ushort,
        _hostAddress: *const ::std::os::raw::c_char,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        SocketDescriptor_SocketDescriptor1(&mut __bindgen_tmp, _port, _hostAddress);
        __bindgen_tmp
    }
}
#[doc = " \\brief Network address for a system"]
#[doc = " \\details Corresponds to a network address<BR>"]
#[doc = " This is not necessarily a unique identifier. For example, if a system has both LAN and internet connections, the system may be identified by either one, depending on who is communicating<BR>"]
#[doc = " Therefore, you should not transmit the SystemAddress over the network and expect it to identify a system, or use it to connect to that system, except in the case where that system is not behind a NAT (such as with a dedciated server)"]
#[doc = " Use RakNetGUID for a unique per-instance of RakPeer to identify systems"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SystemAddress {
    pub address: SystemAddress__bindgen_ty_1,
    #[doc = " This is not used internally, but holds a copy of the port held in the address union, so for debugging it's easier to check what port is being held"]
    pub debugPort: ::std::os::raw::c_ushort,
    #[doc = " \\internal Used internally for fast lookup. Optional (use -1 to do regular lookup). Don't transmit this."]
    pub systemIndex: SystemIndex,
}
#[doc = " SystemAddress, with RAKNET_SUPPORT_IPV6 defined, holds both an sockaddr_in6 and a sockaddr_in"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SystemAddress__bindgen_ty_1 {
    pub addr4: __BindgenUnionField<sockaddr_in>,
    pub bindgen_union_field: [u32; 4usize],
}
extern "C" {
    #[doc = " \\internal Return the size to write to a bitStream"]
    #[link_name = "\u{1}?size@SystemAddress@RakNet@@SAHXZ"]
    pub fn SystemAddress_size() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Hash the system address"]
    #[link_name = "\u{1}?ToInteger@SystemAddress@RakNet@@SAKAEBU12@@Z"]
    pub fn SystemAddress_ToInteger(sa: *const SystemAddress) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Return the IP version, either IPV4 or IPV6"]
    #[doc = " \\return Either 4 or 6"]
    #[link_name = "\u{1}?GetIPVersion@SystemAddress@RakNet@@QEBAEXZ"]
    pub fn SystemAddress_GetIPVersion(this: *const SystemAddress) -> ::std::os::raw::c_uchar;
}
extern "C" {
    #[doc = " \\internal Returns either IPPROTO_IP or IPPROTO_IPV6"]
    #[doc = " \\sa GetIPVersion"]
    #[link_name = "\u{1}?GetIPPROTO@SystemAddress@RakNet@@QEBAIXZ"]
    pub fn SystemAddress_GetIPPROTO(this: *const SystemAddress) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Call SetToLoopback(), with whatever IP version is currently held. Defaults to IPV4"]
    #[link_name = "\u{1}?SetToLoopback@SystemAddress@RakNet@@QEAAXXZ"]
    pub fn SystemAddress_SetToLoopback(this: *mut SystemAddress);
}
extern "C" {
    #[doc = " Call SetToLoopback() with a specific IP version"]
    #[doc = " \\param[in] ipVersion Either 4 for IPV4 or 6 for IPV6"]
    #[link_name = "\u{1}?SetToLoopback@SystemAddress@RakNet@@QEAAXE@Z"]
    pub fn SystemAddress_SetToLoopback1(
        this: *mut SystemAddress,
        ipVersion: ::std::os::raw::c_uchar,
    );
}
extern "C" {
    #[doc = " \\return If was set to 127.0.0.1 or ::1"]
    #[link_name = "\u{1}?IsLoopback@SystemAddress@RakNet@@QEBA_NXZ"]
    pub fn SystemAddress_IsLoopback(this: *const SystemAddress) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?ToString@SystemAddress@RakNet@@QEBAPEBD_ND@Z"]
    pub fn SystemAddress_ToString(
        this: *const SystemAddress,
        writePort: bool,
        portDelineator: ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}?ToString@SystemAddress@RakNet@@QEBAX_NPEADD@Z"]
    pub fn SystemAddress_ToString1(
        this: *const SystemAddress,
        writePort: bool,
        dest: *mut ::std::os::raw::c_char,
        portDelineator: ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Set the system address from a printable IP string, for example \"192.0.2.1\" or \"2001:db8:63b3:1::3490\""]
    #[doc = " You can write the port as well, using the portDelineator, for example \"192.0.2.1|1234\""]
    #[doc = " \\param[in] str A printable IP string, for example \"192.0.2.1\" or \"2001:db8:63b3:1::3490\". Pass 0 for \\a str to set to UNASSIGNED_SYSTEM_ADDRESS"]
    #[doc = " \\param[in] portDelineator if \\a str contains a port, delineate the port with this character. portDelineator should not be '.', ':', '%', '-', '/', a number, or a-f"]
    #[doc = " \\param[in] ipVersion Only used if str is a pre-defined address in the wrong format, such as 127.0.0.1 but you want ip version 6, so you can pass 6 here to do the conversion"]
    #[doc = " \\note The current port is unchanged if a port is not specified in \\a str"]
    #[doc = " \\return True on success, false on ipVersion does not match type of passed string"]
    #[link_name = "\u{1}?FromString@SystemAddress@RakNet@@QEAA_NPEBDDH@Z"]
    pub fn SystemAddress_FromString(
        this: *mut SystemAddress,
        str: *const ::std::os::raw::c_char,
        portDelineator: ::std::os::raw::c_char,
        ipVersion: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[doc = " Same as FromString(), but you explicitly set a port at the same time"]
    #[link_name = "\u{1}?FromStringExplicitPort@SystemAddress@RakNet@@QEAA_NPEBDGH@Z"]
    pub fn SystemAddress_FromStringExplicitPort(
        this: *mut SystemAddress,
        str: *const ::std::os::raw::c_char,
        port: ::std::os::raw::c_ushort,
        ipVersion: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy the port from another SystemAddress structure"]
    #[link_name = "\u{1}?CopyPort@SystemAddress@RakNet@@QEAAXAEBU12@@Z"]
    pub fn SystemAddress_CopyPort(this: *mut SystemAddress, right: *const SystemAddress);
}
extern "C" {
    #[doc = " Returns if two system addresses have the same IP (port is not checked)"]
    #[link_name = "\u{1}?EqualsExcludingPort@SystemAddress@RakNet@@QEBA_NAEBU12@@Z"]
    pub fn SystemAddress_EqualsExcludingPort(
        this: *const SystemAddress,
        right: *const SystemAddress,
    ) -> bool;
}
extern "C" {
    #[doc = " Returns the port in host order (this is what you normally use)"]
    #[link_name = "\u{1}?GetPort@SystemAddress@RakNet@@QEBAGXZ"]
    pub fn SystemAddress_GetPort(this: *const SystemAddress) -> ::std::os::raw::c_ushort;
}
extern "C" {
    #[doc = " \\internal Returns the port in network order"]
    #[link_name = "\u{1}?GetPortNetworkOrder@SystemAddress@RakNet@@QEBAGXZ"]
    pub fn SystemAddress_GetPortNetworkOrder(
        this: *const SystemAddress,
    ) -> ::std::os::raw::c_ushort;
}
extern "C" {
    #[doc = " Sets the port. The port value should be in host order (this is what you normally use)"]
    #[doc = " Renamed from SetPort because of winspool.h http://edn.embarcadero.com/article/21494"]
    #[link_name = "\u{1}?SetPortHostOrder@SystemAddress@RakNet@@QEAAXG@Z"]
    pub fn SystemAddress_SetPortHostOrder(this: *mut SystemAddress, s: ::std::os::raw::c_ushort);
}
extern "C" {
    #[doc = " \\internal Sets the port. The port value should already be in network order."]
    #[link_name = "\u{1}?SetPortNetworkOrder@SystemAddress@RakNet@@QEAAXG@Z"]
    pub fn SystemAddress_SetPortNetworkOrder(this: *mut SystemAddress, s: ::std::os::raw::c_ushort);
}
extern "C" {
    #[doc = " Old version, for crap platforms that don't support newer socket functions"]
    #[link_name = "\u{1}?SetBinaryAddress@SystemAddress@RakNet@@QEAA_NPEBDD@Z"]
    pub fn SystemAddress_SetBinaryAddress(
        this: *mut SystemAddress,
        str: *const ::std::os::raw::c_char,
        portDelineator: ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Old version, for crap platforms that don't support newer socket functions"]
    #[link_name = "\u{1}?ToString_Old@SystemAddress@RakNet@@QEBAX_NPEADD@Z"]
    pub fn SystemAddress_ToString_Old(
        this: *const SystemAddress,
        writePort: bool,
        dest: *mut ::std::os::raw::c_char,
        portDelineator: ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " \\internal sockaddr_in6 requires extra data beyond just the IP and port. Copy that extra data from an existing SystemAddress that already has it"]
    #[link_name = "\u{1}?FixForIPVersion@SystemAddress@RakNet@@QEAAXAEBU12@@Z"]
    pub fn SystemAddress_FixForIPVersion(
        this: *mut SystemAddress,
        boundAddressToSocket: *const SystemAddress,
    );
}
extern "C" {
    #[link_name = "\u{1}?IsLANAddress@SystemAddress@RakNet@@QEAA_NXZ"]
    pub fn SystemAddress_IsLANAddress(this: *mut SystemAddress) -> bool;
}
extern "C" {
    #[doc = " Constructors"]
    #[link_name = "\u{1}??0SystemAddress@RakNet@@QEAA@XZ"]
    pub fn SystemAddress_SystemAddress(this: *mut SystemAddress);
}
extern "C" {
    #[link_name = "\u{1}??0SystemAddress@RakNet@@QEAA@PEBD@Z"]
    pub fn SystemAddress_SystemAddress1(
        this: *mut SystemAddress,
        str: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}??0SystemAddress@RakNet@@QEAA@PEBDG@Z"]
    pub fn SystemAddress_SystemAddress2(
        this: *mut SystemAddress,
        str: *const ::std::os::raw::c_char,
        port: ::std::os::raw::c_ushort,
    );
}
impl SystemAddress {
    #[inline]
    pub unsafe fn size() -> ::std::os::raw::c_int {
        SystemAddress_size()
    }
    #[inline]
    pub unsafe fn ToInteger(sa: *const SystemAddress) -> ::std::os::raw::c_ulong {
        SystemAddress_ToInteger(sa)
    }
    #[inline]
    pub unsafe fn GetIPVersion(&self) -> ::std::os::raw::c_uchar {
        SystemAddress_GetIPVersion(self)
    }
    #[inline]
    pub unsafe fn GetIPPROTO(&self) -> ::std::os::raw::c_uint {
        SystemAddress_GetIPPROTO(self)
    }
    #[inline]
    pub unsafe fn SetToLoopback(&mut self) {
        SystemAddress_SetToLoopback(self)
    }
    #[inline]
    pub unsafe fn SetToLoopback1(&mut self, ipVersion: ::std::os::raw::c_uchar) {
        SystemAddress_SetToLoopback1(self, ipVersion)
    }
    #[inline]
    pub unsafe fn IsLoopback(&self) -> bool {
        SystemAddress_IsLoopback(self)
    }
    #[inline]
    pub unsafe fn ToString(
        &self,
        writePort: bool,
        portDelineator: ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char {
        SystemAddress_ToString(self, writePort, portDelineator)
    }
    #[inline]
    pub unsafe fn ToString1(
        &self,
        writePort: bool,
        dest: *mut ::std::os::raw::c_char,
        portDelineator: ::std::os::raw::c_char,
    ) {
        SystemAddress_ToString1(self, writePort, dest, portDelineator)
    }
    #[inline]
    pub unsafe fn FromString(
        &mut self,
        str: *const ::std::os::raw::c_char,
        portDelineator: ::std::os::raw::c_char,
        ipVersion: ::std::os::raw::c_int,
    ) -> bool {
        SystemAddress_FromString(self, str, portDelineator, ipVersion)
    }
    #[inline]
    pub unsafe fn FromStringExplicitPort(
        &mut self,
        str: *const ::std::os::raw::c_char,
        port: ::std::os::raw::c_ushort,
        ipVersion: ::std::os::raw::c_int,
    ) -> bool {
        SystemAddress_FromStringExplicitPort(self, str, port, ipVersion)
    }
    #[inline]
    pub unsafe fn CopyPort(&mut self, right: *const SystemAddress) {
        SystemAddress_CopyPort(self, right)
    }
    #[inline]
    pub unsafe fn EqualsExcludingPort(&self, right: *const SystemAddress) -> bool {
        SystemAddress_EqualsExcludingPort(self, right)
    }
    #[inline]
    pub unsafe fn GetPort(&self) -> ::std::os::raw::c_ushort {
        SystemAddress_GetPort(self)
    }
    #[inline]
    pub unsafe fn GetPortNetworkOrder(&self) -> ::std::os::raw::c_ushort {
        SystemAddress_GetPortNetworkOrder(self)
    }
    #[inline]
    pub unsafe fn SetPortHostOrder(&mut self, s: ::std::os::raw::c_ushort) {
        SystemAddress_SetPortHostOrder(self, s)
    }
    #[inline]
    pub unsafe fn SetPortNetworkOrder(&mut self, s: ::std::os::raw::c_ushort) {
        SystemAddress_SetPortNetworkOrder(self, s)
    }
    #[inline]
    pub unsafe fn SetBinaryAddress(
        &mut self,
        str: *const ::std::os::raw::c_char,
        portDelineator: ::std::os::raw::c_char,
    ) -> bool {
        SystemAddress_SetBinaryAddress(self, str, portDelineator)
    }
    #[inline]
    pub unsafe fn ToString_Old(
        &self,
        writePort: bool,
        dest: *mut ::std::os::raw::c_char,
        portDelineator: ::std::os::raw::c_char,
    ) {
        SystemAddress_ToString_Old(self, writePort, dest, portDelineator)
    }
    #[inline]
    pub unsafe fn FixForIPVersion(&mut self, boundAddressToSocket: *const SystemAddress) {
        SystemAddress_FixForIPVersion(self, boundAddressToSocket)
    }
    #[inline]
    pub unsafe fn IsLANAddress(&mut self) -> bool {
        SystemAddress_IsLANAddress(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        SystemAddress_SystemAddress(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(str: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        SystemAddress_SystemAddress1(&mut __bindgen_tmp, str);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new2(str: *const ::std::os::raw::c_char, port: ::std::os::raw::c_ushort) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        SystemAddress_SystemAddress2(&mut __bindgen_tmp, str, port);
        __bindgen_tmp
    }
}
#[doc = " Uniquely identifies an instance of RakPeer. Use RakPeer::GetGuidFromSystemAddress() and RakPeer::GetSystemAddressFromGuid() to go between SystemAddress and RakNetGUID"]
#[doc = " Use RakPeer::GetGuidFromSystemAddress(UNASSIGNED_SYSTEM_ADDRESS) to get your own GUID"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RakNetGUID {
    pub g: u64,
    pub systemIndex: SystemIndex,
}
extern "C" {
    #[link_name = "\u{1}?ToString@RakNetGUID@RakNet@@QEBAPEBDXZ"]
    pub fn RakNetGUID_ToString(this: *const RakNetGUID) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}?ToString@RakNetGUID@RakNet@@QEBAXPEAD@Z"]
    pub fn RakNetGUID_ToString1(this: *const RakNetGUID, dest: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}?FromString@RakNetGUID@RakNet@@QEAA_NPEBD@Z"]
    pub fn RakNetGUID_FromString(
        this: *mut RakNetGUID,
        source: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?ToUint32@RakNetGUID@RakNet@@SAKAEBU12@@Z"]
    pub fn RakNetGUID_ToUint32(g: *const RakNetGUID) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}??0RakNetGUID@RakNet@@QEAA@XZ"]
    pub fn RakNetGUID_RakNetGUID(this: *mut RakNetGUID);
}
impl RakNetGUID {
    #[inline]
    pub unsafe fn ToString(&self) -> *const ::std::os::raw::c_char {
        RakNetGUID_ToString(self)
    }
    #[inline]
    pub unsafe fn ToString1(&self, dest: *mut ::std::os::raw::c_char) {
        RakNetGUID_ToString1(self, dest)
    }
    #[inline]
    pub unsafe fn FromString(&mut self, source: *const ::std::os::raw::c_char) -> bool {
        RakNetGUID_FromString(self, source)
    }
    #[inline]
    pub unsafe fn ToUint32(g: *const RakNetGUID) -> ::std::os::raw::c_ulong {
        RakNetGUID_ToUint32(g)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        RakNetGUID_RakNetGUID(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}

#[derive(Debug, Copy, Clone)]
#[repr(C)]
pub struct AddressOrGUID {
    pub rakNetGuid: RakNetGUID,
    pub systemAddress: SystemAddress,
}
extern "C" {
    #[link_name = "\u{1}?ToInteger@AddressOrGUID@RakNet@@SAKAEBU12@@Z"]
    pub fn AddressOrGUID_ToInteger(aog: *const AddressOrGUID) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}?ToString@AddressOrGUID@RakNet@@QEBAPEBD_N@Z"]
    pub fn AddressOrGUID_ToString(
        this: *const AddressOrGUID,
        writePort: bool,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}?ToString@AddressOrGUID@RakNet@@QEBAX_NPEAD@Z"]
    pub fn AddressOrGUID_ToString1(
        this: *const AddressOrGUID,
        writePort: bool,
        dest: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}??0AddressOrGUID@RakNet@@QEAA@PEAUPacket@1@@Z"]
    pub fn AddressOrGUID_AddressOrGUID(this: *mut AddressOrGUID, packet: *mut Packet);
}
impl AddressOrGUID {
    #[inline]
    pub unsafe fn ToInteger(aog: *const AddressOrGUID) -> ::std::os::raw::c_ulong {
        AddressOrGUID_ToInteger(aog)
    }
    #[inline]
    pub unsafe fn ToString(&self, writePort: bool) -> *const ::std::os::raw::c_char {
        AddressOrGUID_ToString(self, writePort)
    }
    #[inline]
    pub unsafe fn ToString1(&self, writePort: bool, dest: *mut ::std::os::raw::c_char) {
        AddressOrGUID_ToString1(self, writePort, dest)
    }
    #[inline]
    pub unsafe fn new(packet: *mut Packet) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        AddressOrGUID_AddressOrGUID(&mut __bindgen_tmp, packet);
        __bindgen_tmp
    }
}
#[doc = " This represents a user message from another system."]
#[repr(C)]
pub struct Packet {
    #[doc = " The system that send this packet."]
    pub systemAddress: SystemAddress,
    #[doc = " A unique identifier for the system that sent this packet, regardless of IP address (internal / external / remote system)"]
    #[doc = " Only valid once a connection has been established (ID_CONNECTION_REQUEST_ACCEPTED, or ID_NEW_INCOMING_CONNECTION)"]
    #[doc = " Until that time, will be UNASSIGNED_RAKNET_GUID"]
    pub guid: RakNetGUID,
    #[doc = " The length of the data in bytes"]
    pub length: ::std::os::raw::c_uint,
    #[doc = " The length of the data in bits"]
    pub bitSize: BitSize_t,
    #[doc = " The data from the sender"]
    pub data: *mut ::std::os::raw::c_uchar,
    #[doc = " @internal"]
    #[doc = " Indicates whether to delete the data, or to simply delete the packet."]
    pub deleteData: bool,
    #[doc = " @internal"]
    #[doc = " If true, this message is meant for the user, not for the plugins, so do not process it through plugins"]
    pub wasGeneratedLocally: bool,
}
pub type RNS2SendResult = ::std::os::raw::c_int;
pub mod RNS2Type {
    pub type Type = i32;
    pub const RNS2T_WINDOWS_STORE_8: Type = 0;
    pub const RNS2T_PS3: Type = 1;
    pub const RNS2T_PS4: Type = 2;
    pub const RNS2T_CHROME: Type = 3;
    pub const RNS2T_VITA: Type = 4;
    pub const RNS2T_XBOX_360: Type = 5;
    pub const RNS2T_XBOX_720: Type = 6;
    pub const RNS2T_WINDOWS: Type = 7;
    pub const RNS2T_LINUX: Type = 8;
}
#[repr(C)]
pub struct RNS2_SendParameters {
    pub data: *mut ::std::os::raw::c_char,
    pub length: ::std::os::raw::c_int,
    pub systemAddress: SystemAddress,
    pub ttl: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct RNS2RecvStruct {
    pub data: [::std::os::raw::c_char; 1492usize],
    pub bytesRead: ::std::os::raw::c_int,
    pub systemAddress: SystemAddress,
    pub timeRead: TimeUS,
    pub socket: *mut RakNetSocket2,
}
#[repr(C)]
pub struct RNS2EventHandler__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct RNS2EventHandler {
    pub vtable_: *const RNS2EventHandler__bindgen_vtable,
}
#[repr(C)]
pub struct RakNetSocket2__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
pub struct RakNetSocket2 {
    pub vtable_: *const RakNetSocket2__bindgen_vtable,
    pub eventHandler: *mut RNS2EventHandler,
    pub socketType: RNS2Type::Type,
    pub boundAddress: SystemAddress,
    pub userConnectionSocketIndex: ::std::os::raw::c_uint,
}
extern "C" {
    #[link_name = "\u{1}?SetRecvEventHandler@RakNetSocket2@RakNet@@QEAAXPEAVRNS2EventHandler@2@@Z"]
    pub fn RakNetSocket2_SetRecvEventHandler(
        this: *mut RakNetSocket2,
        _eventHandler: *mut RNS2EventHandler,
    );
}
extern "C" {
    #[link_name = "\u{1}?GetSocketType@RakNetSocket2@RakNet@@QEBA?AW4RNS2Type@2@XZ"]
    pub fn RakNetSocket2_GetSocketType(this: *const RakNetSocket2) -> RNS2Type::Type;
}
extern "C" {
    #[link_name = "\u{1}?SetSocketType@RakNetSocket2@RakNet@@QEAAXW4RNS2Type@2@@Z"]
    pub fn RakNetSocket2_SetSocketType(this: *mut RakNetSocket2, t: RNS2Type::Type);
}
extern "C" {
    #[link_name = "\u{1}?IsBerkleySocket@RakNetSocket2@RakNet@@QEBA_NXZ"]
    pub fn RakNetSocket2_IsBerkleySocket(this: *const RakNetSocket2) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?GetBoundAddress@RakNetSocket2@RakNet@@QEBA?AUSystemAddress@2@XZ"]
    pub fn RakNetSocket2_GetBoundAddress(this: *const RakNetSocket2) -> SystemAddress;
}
extern "C" {
    #[link_name = "\u{1}?GetUserConnectionSocketIndex@RakNetSocket2@RakNet@@QEBAIXZ"]
    pub fn RakNetSocket2_GetUserConnectionSocketIndex(
        this: *const RakNetSocket2,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}?SetUserConnectionSocketIndex@RakNetSocket2@RakNet@@QEAAXI@Z"]
    pub fn RakNetSocket2_SetUserConnectionSocketIndex(
        this: *mut RakNetSocket2,
        i: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[link_name = "\u{1}?GetEventHandler@RakNetSocket2@RakNet@@QEBAPEAVRNS2EventHandler@2@XZ"]
    pub fn RakNetSocket2_GetEventHandler(this: *const RakNetSocket2) -> *mut RNS2EventHandler;
}
extern "C" {
    #[link_name = "\u{1}?GetMyIP@RakNetSocket2@RakNet@@SAXQEAUSystemAddress@2@@Z"]
    pub fn RakNetSocket2_GetMyIP(addresses: *mut SystemAddress);
}
extern "C" {
    #[link_name = "\u{1}?DomainNameToIP@RakNetSocket2@RakNet@@SAXPEBDQEAD@Z"]
    pub fn RakNetSocket2_DomainNameToIP(
        domainName: *const ::std::os::raw::c_char,
        ip: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}??0RakNetSocket2@RakNet@@QEAA@XZ"]
    pub fn RakNetSocket2_RakNetSocket2(this: *mut RakNetSocket2);
}
impl RakNetSocket2 {
    #[inline]
    pub unsafe fn SetRecvEventHandler(&mut self, _eventHandler: *mut RNS2EventHandler) {
        RakNetSocket2_SetRecvEventHandler(self, _eventHandler)
    }
    #[inline]
    pub unsafe fn GetSocketType(&self) -> RNS2Type::Type {
        RakNetSocket2_GetSocketType(self)
    }
    #[inline]
    pub unsafe fn SetSocketType(&mut self, t: RNS2Type::Type) {
        RakNetSocket2_SetSocketType(self, t)
    }
    #[inline]
    pub unsafe fn IsBerkleySocket(&self) -> bool {
        RakNetSocket2_IsBerkleySocket(self)
    }
    #[inline]
    pub unsafe fn GetBoundAddress(&self) -> SystemAddress {
        RakNetSocket2_GetBoundAddress(self)
    }
    #[inline]
    pub unsafe fn GetUserConnectionSocketIndex(&self) -> ::std::os::raw::c_uint {
        RakNetSocket2_GetUserConnectionSocketIndex(self)
    }
    #[inline]
    pub unsafe fn SetUserConnectionSocketIndex(&mut self, i: ::std::os::raw::c_uint) {
        RakNetSocket2_SetUserConnectionSocketIndex(self, i)
    }
    #[inline]
    pub unsafe fn GetEventHandler(&self) -> *mut RNS2EventHandler {
        RakNetSocket2_GetEventHandler(self)
    }
    #[inline]
    pub unsafe fn GetMyIP(addresses: *mut SystemAddress) {
        RakNetSocket2_GetMyIP(addresses)
    }
    #[inline]
    pub unsafe fn DomainNameToIP(
        domainName: *const ::std::os::raw::c_char,
        ip: *mut ::std::os::raw::c_char,
    ) {
        RakNetSocket2_DomainNameToIP(domainName, ip)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        RakNetSocket2_RakNetSocket2(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}??_DRakNetSocket2@RakNet@@QEAAXXZ"]
    pub fn RakNetSocket2_RakNetSocket2_destructor(this: *mut RakNetSocket2);
}
#[repr(C)]
#[derive(Debug)]
pub struct PluginInterface2 {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct RakNetStatistics {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct RakPeerInterface__bindgen_vtable {
    destruct: *mut std::os::raw::c_void,
    pub Startup: extern "thiscall" fn(
        this: *mut ::std::os::raw::c_void,
        maxConnections: ::std::os::raw::c_uint,
        socketDescriptors: *mut SocketDescriptor,
        socketDescriptorCount: ::std::os::raw::c_uint,
        threadPriority: ::std::os::raw::c_int,
    ) -> StartupResult::Type,
    pub InitializeSecurity: extern "thiscall" fn(
        this: *mut ::std::os::raw::c_void,
        publicKey: *const ::std::os::raw::c_char,
        privateKey: *const ::std::os::raw::c_char,
        bRequireClientKey: bool,
    ) -> bool,
    pub DisableSecurity: extern "thiscall" fn(this: *mut ::std::os::raw::c_void),
    pub AddToSecurityExceptionList:
        extern "thiscall" fn(this: *mut ::std::os::raw::c_void, ip: *const ::std::os::raw::c_char),
    pub RemoveFromSecurityExceptionList:
        extern "thiscall" fn(this: *mut ::std::os::raw::c_void, ip: *const ::std::os::raw::c_char),
    pub IsInSecurityExceptionList: extern "thiscall" fn(
        this: *mut ::std::os::raw::c_void,
        ip: *const ::std::os::raw::c_char,
    ) -> bool,
    pub SetMaximumIncomingConnections: extern "thiscall" fn(
        this: *mut ::std::os::raw::c_void,
        numberAllowed: ::std::os::raw::c_ushort,
    ),
    pub GetMaximumIncomingConnections:
        extern "thiscall" fn(this: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_uint,
    pub NumberOfConnections:
        extern "thiscall" fn(this: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_ushort,
    pub SetIncomingPassword: extern "thiscall" fn(
        this: *mut ::std::os::raw::c_void,
        passwordData: *const ::std::os::raw::c_char,
        passwordDataLength: ::std::os::raw::c_int,
    ),
    pub GetIncomingPassword: extern "thiscall" fn(
        this: *mut ::std::os::raw::c_void,
        passwordData: *mut ::std::os::raw::c_char,
        passwordDataLength: *mut ::std::os::raw::c_int,
    ),
    pub Connect: extern "thiscall" fn(
        this: *mut ::std::os::raw::c_void,
        host: *const ::std::os::raw::c_char,
        remotePort: ::std::os::raw::c_ushort,
        passwordData: *const ::std::os::raw::c_char,
        passwordDataLength: ::std::os::raw::c_int,
        publicKey: *mut PublicKey,
        connectionSocketIndex: ::std::os::raw::c_uint,
        sendConnectionAttemptCount: ::std::os::raw::c_uint,
        timeBetweenSendConnectionAttemptsMS: ::std::os::raw::c_uint,
        timeoutTime: TimeMS,
    ) -> ConnectionAttemptResult::Type,
    pub ConnectWithSocket: extern "thiscall" fn(
        this: *mut ::std::os::raw::c_void,
        host: *const ::std::os::raw::c_char,
        remotePort: ::std::os::raw::c_ushort,
        passwordData: *const ::std::os::raw::c_char,
        passwordDataLength: ::std::os::raw::c_int,
        socket: *mut RakNetSocket2,
        publicKey: *mut PublicKey,
        sendConnectionAttemptCount: ::std::os::raw::c_uint,
        timeBetweenSendConnectionAttemptsMS: ::std::os::raw::c_uint,
        timeoutTime: TimeMS,
    ) -> ConnectionAttemptResult::Type,
    pub Shutdown: extern "thiscall" fn(
        this: *mut ::std::os::raw::c_void,
        blockDuration: ::std::os::raw::c_uint,
        orderingChannel: ::std::os::raw::c_uchar,
        disconnectionNotificationPriority: PacketPriority::Type,
    ),
    pub IsActive: extern "thiscall" fn(this: *mut ::std::os::raw::c_void) -> bool,
    pub GetConnectionList: extern "thiscall" fn(
        this: *mut ::std::os::raw::c_void,
        remoteSystems: *mut SystemAddress,
        numberOfSystems: *mut ::std::os::raw::c_ushort,
    ) -> bool,
    pub GetNextSendReceipt: extern "thiscall" fn(this: *mut ::std::os::raw::c_void) -> u32,
    pub IncrementNextSendReceipt: extern "thiscall" fn(this: *mut ::std::os::raw::c_void) -> u32,
    // ?
    pub SendBitstream: extern "thiscall" fn(
        this: *mut ::std::os::raw::c_void,
        bitStream: *const BitStream,
        priority: PacketPriority::Type,
        reliability: PacketReliability::Type,
        orderingChannel: ::std::os::raw::c_char,
        systemIdentifier: AddressOrGUID,
        broadcast: bool,
        forceReceiptNumber: u32,
    ) -> u32,
    pub Send: extern "thiscall" fn(
        this: *mut ::std::os::raw::c_void,
        data: *const ::std::os::raw::c_char,
        length: ::std::os::raw::c_int,
        priority: PacketPriority::Type,
        reliability: PacketReliability::Type,
        orderingChannel: ::std::os::raw::c_char,
        systemIdentifier: AddressOrGUID,
        broadcast: bool,
        forceReceiptNumber: u32,
    ) -> u32,
    pub SendLoopback: extern "thiscall" fn(
        this: *mut ::std::os::raw::c_void,
        data: *const ::std::os::raw::c_char,
        length: ::std::os::raw::c_int,
    ),
    // >
    pub SendList: extern "thiscall" fn(
        this: *mut ::std::os::raw::c_void,
        data: *mut *const ::std::os::raw::c_char,
        lengths: *const ::std::os::raw::c_int,
        numParameters: ::std::os::raw::c_int,
        priority: PacketPriority::Type,
        reliability: PacketReliability::Type,
        orderingChannel: ::std::os::raw::c_char,
        systemIdentifier: AddressOrGUID,
        broadcast: bool,
        forceReceiptNumber: u32,
    ) -> u32,
    pub Receive: extern "thiscall" fn(this: *mut ::std::os::raw::c_void) -> *mut Packet,
    pub DeallocatePacket:
        extern "thiscall" fn(this: *mut ::std::os::raw::c_void, packet: *mut Packet),
    pub GetMaximumNumberOfPeers:
        extern "thiscall" fn(this: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_uint,
    pub CloseConnection: extern "thiscall" fn(
        this: *mut ::std::os::raw::c_void,
        target: AddressOrGUID,
        sendDisconnectionNotification: bool,
        orderingChannel: ::std::os::raw::c_uchar,
        disconnectionNotificationPriority: PacketPriority::Type,
    ),
    pub GetConnectionState: extern "thiscall" fn(
        this: *mut ::std::os::raw::c_void,
        systemIdentifier: AddressOrGUID,
    ) -> ConnectionState::Type,
    pub CancelConnectionAttempt:
        extern "thiscall" fn(this: *mut ::std::os::raw::c_void, target: SystemAddress),
    pub GetIndexFromSystemAddress: extern "thiscall" fn(
        this: *mut ::std::os::raw::c_void,
        systemAddress: SystemAddress,
    ) -> ::std::os::raw::c_int,
    pub GetSystemAddressFromIndex: extern "thiscall" fn(
        this: *mut ::std::os::raw::c_void,
        index: ::std::os::raw::c_uint,
    ) -> SystemAddress,
    pub GetGUIDFromIndex: extern "thiscall" fn(
        this: *mut ::std::os::raw::c_void,
        index: ::std::os::raw::c_uint,
    ) -> RakNetGUID,
    pub GetSystemList: extern "thiscall" fn(
        this: *mut ::std::os::raw::c_void,
        addresses: *mut List<SystemAddress>,
        guids: *mut List<RakNetGUID>,
    ),
    pub AddToBanList: extern "thiscall" fn(
        this: *mut ::std::os::raw::c_void,
        IP: *const ::std::os::raw::c_char,
        milliseconds: TimeMS,
    ),
    pub RemoveFromBanList:
        extern "thiscall" fn(this: *mut ::std::os::raw::c_void, IP: *const ::std::os::raw::c_char),
    pub ClearBanList: extern "thiscall" fn(this: *mut ::std::os::raw::c_void),
    pub IsBanned: extern "thiscall" fn(
        this: *mut ::std::os::raw::c_void,
        IP: *const ::std::os::raw::c_char,
    ) -> bool,
    pub SetLimitIPConnectionFrequency:
        extern "thiscall" fn(this: *mut ::std::os::raw::c_void, b: bool),
    pub Ping: extern "thiscall" fn(this: *mut ::std::os::raw::c_void, target: SystemAddress),
    pub PingEx: extern "thiscall" fn(
        this: *mut ::std::os::raw::c_void,
        host: *const ::std::os::raw::c_char,
        remotePort: ::std::os::raw::c_ushort,
        onlyReplyOnAcceptingConnections: bool,
        connectionSocketIndex: ::std::os::raw::c_uint,
    ) -> bool,
    pub GetAveragePing: extern "thiscall" fn(
        this: *mut ::std::os::raw::c_void,
        systemIdentifier: AddressOrGUID,
    ) -> ::std::os::raw::c_int,
    pub GetLastPing: extern "thiscall" fn(
        this: *mut ::std::os::raw::c_void,
        systemIdentifier: AddressOrGUID,
    ) -> ::std::os::raw::c_int,
    pub GetLowestPing: extern "thiscall" fn(
        this: *mut ::std::os::raw::c_void,
        systemIdentifier: AddressOrGUID,
    ) -> ::std::os::raw::c_int,
    pub SetOccasionalPing: extern "thiscall" fn(this: *mut ::std::os::raw::c_void, doPing: bool),
    pub GetClockDifferential: extern "thiscall" fn(
        this: *mut ::std::os::raw::c_void,
        systemIdentifier: AddressOrGUID,
    ) -> Time,
    pub SetOfflinePingResponse: extern "thiscall" fn(
        this: *mut ::std::os::raw::c_void,
        data: *const ::std::os::raw::c_char,
        length: ::std::os::raw::c_uint,
    ),
    pub GetOfflinePingResponse: extern "thiscall" fn(
        this: *mut ::std::os::raw::c_void,
        data: *mut *mut ::std::os::raw::c_char,
        length: *mut ::std::os::raw::c_uint,
    ),
    pub GetInternalID: extern "thiscall" fn(
        this: *mut ::std::os::raw::c_void,
        systemAddress: SystemAddress,
        index: ::std::os::raw::c_int,
    ) -> SystemAddress,
    pub SetInternalID: extern "thiscall" fn(
        this: *mut ::std::os::raw::c_void,
        systemAddress: SystemAddress,
        index: ::std::os::raw::c_int,
    ),
    pub GetExternalID: extern "thiscall" fn(
        this: *mut ::std::os::raw::c_void,
        target: SystemAddress,
    ) -> SystemAddress,
    pub GetMyGUID: extern "thiscall" fn(this: *mut ::std::os::raw::c_void) -> RakNetGUID,
    pub GetMyBoundAddress: extern "thiscall" fn(
        this: *mut ::std::os::raw::c_void,
        socketIndex: ::std::os::raw::c_int,
    ) -> SystemAddress,
    pub Get64BitUniqueRandomNumber: extern "thiscall" fn() -> u64,
    pub GetGuidFromSystemAddress: extern "thiscall" fn(
        this: *mut ::std::os::raw::c_void,
        input: SystemAddress,
    ) -> *const RakNetGUID,
    pub GetSystemAddressFromGuid:
        extern "thiscall" fn(this: *mut ::std::os::raw::c_void, input: RakNetGUID) -> SystemAddress,
    pub GetClientPublicKeyFromSystemAddress: extern "thiscall" fn(
        this: *mut ::std::os::raw::c_void,
        input: SystemAddress,
        client_public_key: *mut ::std::os::raw::c_char,
    ) -> bool,
    pub SetTimeoutTime: extern "thiscall" fn(
        this: *mut ::std::os::raw::c_void,
        timeMS: TimeMS,
        target: SystemAddress,
    ),
    pub GetTimeoutTime:
        extern "thiscall" fn(this: *mut ::std::os::raw::c_void, target: SystemAddress) -> TimeMS,
    pub GetMTUSize: extern "thiscall" fn(
        this: *mut ::std::os::raw::c_void,
        target: SystemAddress,
    ) -> ::std::os::raw::c_int,
    pub GetNumberOfAddresses:
        extern "thiscall" fn(this: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_uint,
    pub GetLocalIP: extern "thiscall" fn(
        this: *mut ::std::os::raw::c_void,
        index: ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char,
    pub IsLocalIP: extern "thiscall" fn(
        this: *mut ::std::os::raw::c_void,
        ip: *const ::std::os::raw::c_char,
    ) -> bool,
    pub AllowConnectionResponseIPMigration:
        extern "thiscall" fn(this: *mut ::std::os::raw::c_void, allow: bool),
    pub AdvertiseSystem: extern "thiscall" fn(
        this: *mut ::std::os::raw::c_void,
        host: *const ::std::os::raw::c_char,
        remotePort: ::std::os::raw::c_ushort,
        data: *const ::std::os::raw::c_char,
        dataLength: ::std::os::raw::c_int,
        connectionSocketIndex: ::std::os::raw::c_uint,
    ) -> bool,
    pub SetSplitMessageProgressInterval:
        extern "thiscall" fn(this: *mut ::std::os::raw::c_void, interval: ::std::os::raw::c_int),
    pub GetSplitMessageProgressInterval:
        extern "thiscall" fn(this: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    pub SetUnreliableTimeout:
        extern "thiscall" fn(this: *mut ::std::os::raw::c_void, timeoutMS: TimeMS),
    pub SendTTL: extern "thiscall" fn(
        this: *mut ::std::os::raw::c_void,
        host: *const ::std::os::raw::c_char,
        remotePort: ::std::os::raw::c_ushort,
        ttl: ::std::os::raw::c_int,
        connectionSocketIndex: ::std::os::raw::c_uint,
    ),
    pub AttachPlugin:
        extern "thiscall" fn(this: *mut ::std::os::raw::c_void, plugin: *mut PluginInterface2),
    pub DetachPlugin: extern "thiscall" fn(
        this: *mut ::std::os::raw::c_void,
        messageHandler: *mut PluginInterface2,
    ),
    pub PushBackPacket: extern "thiscall" fn(
        this: *mut ::std::os::raw::c_void,
        packet: *mut Packet,
        pushAtHead: bool,
    ),
    pub ChangeSystemAddress: extern "thiscall" fn(
        this: *mut ::std::os::raw::c_void,
        guid: RakNetGUID,
        systemAddress: *const SystemAddress,
    ),
    pub AllocatePacket: extern "thiscall" fn(
        this: *mut ::std::os::raw::c_void,
        dataSize: ::std::os::raw::c_uint,
    ) -> *mut Packet,
    pub GetSocket: extern "thiscall" fn(
        this: *mut ::std::os::raw::c_void,
        target: SystemAddress,
    ) -> *mut RakNetSocket2,
    pub GetSockets: extern "thiscall" fn(
        this: *mut ::std::os::raw::c_void,
        sockets: *mut List<*mut RakNetSocket2>,
    ),
    pub ReleaseSockets: extern "thiscall" fn(
        this: *mut ::std::os::raw::c_void,
        sockets: *mut List<*mut RakNetSocket2>,
    ),
    pub WriteOutOfBandHeader:
        extern "thiscall" fn(this: *mut ::std::os::raw::c_void, bitStream: *mut BitStream),
    pub SetUserUpdateThread: extern "thiscall" fn(
        this: *mut ::std::os::raw::c_void,
        _userUpdateThreadPtr: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut RakPeerInterface, arg2: *mut ::std::os::raw::c_void),
        >,
        _userUpdateThreadData: *mut ::std::os::raw::c_void,
    ),
    pub SetIncomingDatagramEventHandler: extern "thiscall" fn(
        this: *mut ::std::os::raw::c_void,
        _incomingDatagramEventHandler: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut RNS2RecvStruct) -> bool,
        >,
    ),
    pub ApplyNetworkSimulator: extern "thiscall" fn(
        this: *mut ::std::os::raw::c_void,
        packetloss: f32,
        minExtraPing: ::std::os::raw::c_ushort,
        extraPingVariance: ::std::os::raw::c_ushort,
    ),
    pub SetPerConnectionOutgoingBandwidthLimit: extern "thiscall" fn(
        this: *mut ::std::os::raw::c_void,
        maxBitsPerSecond: ::std::os::raw::c_uint,
    ),
    pub IsNetworkSimulatorActive: extern "thiscall" fn(this: *mut ::std::os::raw::c_void) -> bool,
    pub GetStatistics: extern "thiscall" fn(
        this: *mut ::std::os::raw::c_void,
        systemAddress: SystemAddress,
        rns: *mut RakNetStatistics,
    ) -> *mut RakNetStatistics,
    pub GetStatisticsByIndex: extern "thiscall" fn(
        this: *mut ::std::os::raw::c_void,
        index: ::std::os::raw::c_uint,
        rns: *mut RakNetStatistics,
    ) -> bool,
    pub GetStatisticsList: extern "thiscall" fn(
        this: *mut ::std::os::raw::c_void,
        addresses: *mut List<SystemAddress>,
        guids: *mut List<RakNetGUID>,
        statistics: *mut List<RakNetStatistics>,
    ),
    pub GetReceiveBufferSize:
        extern "thiscall" fn(this: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_uint,
    pub RunUpdateCycle: extern "thiscall" fn(
        this: *mut ::std::os::raw::c_void,
        updateBitStream: *mut BitStream,
    ) -> bool,
    pub SendOutOfBand: extern "thiscall" fn(
        this: *mut ::std::os::raw::c_void,
        host: *const ::std::os::raw::c_char,
        remotePort: ::std::os::raw::c_ushort,
        data: *const ::std::os::raw::c_char,
        dataLength: BitSize_t,
        connectionSocketIndex: ::std::os::raw::c_uint,
    ) -> bool,
}
#[doc = " Forward declarations"]
#[repr(C)]
#[derive(Debug)]
pub struct RakPeerInterface {
    pub vtable_: *const RakPeerInterface__bindgen_vtable,
}
extern "C" {
    #[link_name = "\u{1}?GetInstance@RakPeerInterface@RakNet@@SAPEAV12@XZ"]
    pub fn RakPeerInterface_GetInstance() -> *mut RakPeerInterface;
}
extern "C" {
    #[link_name = "\u{1}?DestroyInstance@RakPeerInterface@RakNet@@SAXPEAV12@@Z"]
    pub fn RakPeerInterface_DestroyInstance(i: *mut RakPeerInterface);
}
extern "C" {
    #[doc = " Get a random number (to generate a GUID)"]
    #[link_name = "\u{1}?Get64BitUniqueRandomNumber@RakPeerInterface@RakNet@@SA_KXZ"]
    pub fn RakPeerInterface_Get64BitUniqueRandomNumber() -> u64;
}
impl RakPeerInterface {
    #[inline]
    pub unsafe fn GetInstance() -> *mut RakPeerInterface {
        RakPeerInterface_GetInstance()
    }
    #[inline]
    pub unsafe fn DestroyInstance(i: *mut RakPeerInterface) {
        RakPeerInterface_DestroyInstance(i)
    }
    #[inline]
    pub unsafe fn Get64BitUniqueRandomNumber() -> u64 {
        RakPeerInterface_Get64BitUniqueRandomNumber()
    }
}
#[doc = " This class allows you to write and read native types as a string of bits.  BitStream is used extensively throughout RakNet and is designed to be used by users as well."]
#[doc = " \\sa BitStreamSample.txt"]
#[repr(C)]
pub struct BitStream {
    pub numberOfBitsUsed: BitSize_t,
    pub numberOfBitsAllocated: BitSize_t,
    pub readOffset: BitSize_t,
    pub data: *mut ::std::os::raw::c_uchar,
    #[doc = " true if the internal buffer is copy of the data passed to the constructor"]
    pub copyData: bool,
    #[doc = " BitStreams that use less than BITSTREAM_STACK_ALLOCATION_SIZE use the stack, rather than the heap to store data.  It switches over if BITSTREAM_STACK_ALLOCATION_SIZE is exceeded"]
    pub stackData: [::std::os::raw::c_uchar; 256usize],
}
extern "C" {
    #[link_name = "\u{1}?GetInstance@BitStream@RakNet@@SAPEAV12@XZ"]
    pub fn BitStream_GetInstance() -> *mut BitStream;
}
extern "C" {
    #[link_name = "\u{1}?DestroyInstance@BitStream@RakNet@@SAXPEAV12@@Z"]
    pub fn BitStream_DestroyInstance(i: *mut BitStream);
}
extern "C" {
    #[doc = " Resets the bitstream for reuse."]
    #[link_name = "\u{1}?Reset@BitStream@RakNet@@QEAAXXZ"]
    pub fn BitStream_Reset(this: *mut BitStream);
}
extern "C" {
    #[doc = " \\brief Bidirectional serialize/deserialize an array or casted stream or raw data.  This does NOT do endian swapping."]
    #[doc = " \\param[in] writeToBitstream true to write from your data to this bitstream.  False to read from this bitstream and write to your data"]
    #[doc = " \\param[in] inOutByteArray a byte buffer"]
    #[doc = " \\param[in] numberOfBytes the size of \\a input in bytes"]
    #[doc = " \\return true if \\a writeToBitstream is true.  true if \\a writeToBitstream is false and the read was successful.  false if \\a writeToBitstream is false and the read was not successful."]
    #[link_name = "\u{1}?Serialize@BitStream@RakNet@@QEAA_N_NPEADI@Z"]
    pub fn BitStream_Serialize(
        this: *mut BitStream,
        writeToBitstream: bool,
        inOutByteArray: *mut ::std::os::raw::c_char,
        numberOfBytes: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = " \\brief Serialize a float into 2 bytes, spanning the range between \\a floatMin and \\a floatMax"]
    #[doc = " \\param[in] writeToBitstream true to write from your data to this bitstream.  False to read from this bitstream and write to your data"]
    #[doc = " \\param[in] inOutFloat The float to write"]
    #[doc = " \\param[in] floatMin Predetermined minimum value of f"]
    #[doc = " \\param[in] floatMax Predetermined maximum value of f"]
    #[link_name = "\u{1}?SerializeFloat16@BitStream@RakNet@@QEAA_N_NAEAMMM@Z"]
    pub fn BitStream_SerializeFloat16(
        this: *mut BitStream,
        writeToBitstream: bool,
        inOutFloat: *mut f32,
        floatMin: f32,
        floatMax: f32,
    ) -> bool;
}
extern "C" {
    #[doc = " \\brief Bidirectional serialize/deserialize numberToSerialize bits to/from the input."]
    #[doc = " \\details Right aligned data means in the case of a partial byte, the bits are aligned"]
    #[doc = " from the right (bit 0) rather than the left (as in the normal"]
    #[doc = " internal representation) You would set this to true when"]
    #[doc = " writing user data, and false when copying bitstream data, such"]
    #[doc = " as writing one bitstream to another"]
    #[doc = " \\param[in] writeToBitstream true to write from your data to this bitstream.  False to read from this bitstream and write to your data"]
    #[doc = " \\param[in] inOutByteArray The data"]
    #[doc = " \\param[in] numberOfBitsToSerialize The number of bits to write"]
    #[doc = " \\param[in] rightAlignedBits if true data will be right aligned"]
    #[doc = " \\return true if \\a writeToBitstream is true.  true if \\a writeToBitstream is false and the read was successful.  false if \\a writeToBitstream is false and the read was not successful."]
    #[link_name = "\u{1}?SerializeBits@BitStream@RakNet@@QEAA_N_NPEAEI_N@Z"]
    pub fn BitStream_SerializeBits(
        this: *mut BitStream,
        writeToBitstream: bool,
        inOutByteArray: *mut ::std::os::raw::c_uchar,
        numberOfBitsToSerialize: BitSize_t,
        rightAlignedBits: bool,
    ) -> bool;
}
extern "C" {
    #[doc = " \\brief Read one bitstream to another."]
    #[doc = " \\param[in] numberOfBits bits to read"]
    #[doc = " \\param bitStream the bitstream to read into from"]
    #[doc = " \\return true on success, false on failure."]
    #[link_name = "\u{1}?Read@BitStream@RakNet@@QEAA_NPEAV12@I@Z"]
    pub fn BitStream_Read(
        this: *mut BitStream,
        bitStream: *mut BitStream,
        numberOfBits: BitSize_t,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?Read@BitStream@RakNet@@QEAA_NPEAV12@@Z"]
    pub fn BitStream_Read1(this: *mut BitStream, bitStream: *mut BitStream) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?Read@BitStream@RakNet@@QEAA_NAEAV12@I@Z"]
    pub fn BitStream_Read2(
        this: *mut BitStream,
        bitStream: *mut BitStream,
        numberOfBits: BitSize_t,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?Read@BitStream@RakNet@@QEAA_NAEAV12@@Z"]
    pub fn BitStream_Read3(this: *mut BitStream, bitStream: *mut BitStream) -> bool;
}
extern "C" {
    #[doc = " \\brief Write an array or casted stream or raw data.  This does NOT do endian swapping."]
    #[doc = " \\param[in] inputByteArray a byte buffer"]
    #[doc = " \\param[in] numberOfBytes the size of \\a input in bytes"]
    #[link_name = "\u{1}?Write@BitStream@RakNet@@QEAAXPEBDI@Z"]
    pub fn BitStream_Write(
        this: *mut BitStream,
        inputByteArray: *const ::std::os::raw::c_char,
        numberOfBytes: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " \\brief Write one bitstream to another."]
    #[doc = " \\param[in] numberOfBits bits to write"]
    #[doc = " \\param bitStream the bitstream to copy from"]
    #[link_name = "\u{1}?Write@BitStream@RakNet@@QEAAXPEAV12@I@Z"]
    pub fn BitStream_Write1(
        this: *mut BitStream,
        bitStream: *mut BitStream,
        numberOfBits: BitSize_t,
    );
}
extern "C" {
    #[link_name = "\u{1}?Write@BitStream@RakNet@@QEAAXPEAV12@@Z"]
    pub fn BitStream_Write2(this: *mut BitStream, bitStream: *mut BitStream);
}
extern "C" {
    #[link_name = "\u{1}?Write@BitStream@RakNet@@QEAAXAEAV12@I@Z"]
    pub fn BitStream_Write3(
        this: *mut BitStream,
        bitStream: *mut BitStream,
        numberOfBits: BitSize_t,
    );
}
extern "C" {
    #[link_name = "\u{1}?Write@BitStream@RakNet@@QEAAXAEAV12@@Z"]
    pub fn BitStream_Write4(this: *mut BitStream, bitStream: *mut BitStream);
}
extern "C" {
    #[doc = " \\brief Write a float into 2 bytes, spanning the range between \\a floatMin and \\a floatMax"]
    #[doc = " \\param[in] x The float to write"]
    #[doc = " \\param[in] floatMin Predetermined minimum value of f"]
    #[doc = " \\param[in] floatMax Predetermined maximum value of f"]
    #[link_name = "\u{1}?WriteFloat16@BitStream@RakNet@@QEAAXMMM@Z"]
    pub fn BitStream_WriteFloat16(this: *mut BitStream, x: f32, floatMin: f32, floatMax: f32);
}
extern "C" {
    #[doc = " \\brief Read an array or casted stream of byte."]
    #[doc = " \\details The array is raw data. There is no automatic endian conversion with this function"]
    #[doc = " \\param[in] output The result byte array. It should be larger than @em numberOfBytes."]
    #[doc = " \\param[in] numberOfBytes The number of byte to read"]
    #[doc = " \\return true on success false if there is some missing bytes."]
    #[link_name = "\u{1}?Read@BitStream@RakNet@@QEAA_NPEADI@Z"]
    pub fn BitStream_Read4(
        this: *mut BitStream,
        output: *mut ::std::os::raw::c_char,
        numberOfBytes: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = " \\brief Read a float into 2 bytes, spanning the range between \\a floatMin and \\a floatMax"]
    #[doc = " \\param[in] outFloat The float to read"]
    #[doc = " \\param[in] floatMin Predetermined minimum value of f"]
    #[doc = " \\param[in] floatMax Predetermined maximum value of f"]
    #[link_name = "\u{1}?ReadFloat16@BitStream@RakNet@@QEAA_NAEAMMM@Z"]
    pub fn BitStream_ReadFloat16(
        this: *mut BitStream,
        outFloat: *mut f32,
        floatMin: f32,
        floatMax: f32,
    ) -> bool;
}
extern "C" {
    #[doc = " \\brief Sets the read pointer back to the beginning of your data."]
    #[link_name = "\u{1}?ResetReadPointer@BitStream@RakNet@@QEAAXXZ"]
    pub fn BitStream_ResetReadPointer(this: *mut BitStream);
}
extern "C" {
    #[doc = " \\brief Sets the write pointer back to the beginning of your data."]
    #[link_name = "\u{1}?ResetWritePointer@BitStream@RakNet@@QEAAXXZ"]
    pub fn BitStream_ResetWritePointer(this: *mut BitStream);
}
extern "C" {
    #[doc = " \\brief This is good to call when you are done with the stream to make"]
    #[doc = " sure you didn't leave any data left over void"]
    #[link_name = "\u{1}?AssertStreamEmpty@BitStream@RakNet@@QEAAXXZ"]
    pub fn BitStream_AssertStreamEmpty(this: *mut BitStream);
}
extern "C" {
    #[doc = " \\brief RAKNET_DEBUG_PRINTF the bits in the stream.  Great for debugging."]
    #[link_name = "\u{1}?PrintBits@BitStream@RakNet@@QEBAXPEAD@Z"]
    pub fn BitStream_PrintBits(this: *const BitStream, out: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}?PrintBits@BitStream@RakNet@@QEBAXXZ"]
    pub fn BitStream_PrintBits1(this: *const BitStream);
}
extern "C" {
    #[link_name = "\u{1}?PrintHex@BitStream@RakNet@@QEBAXPEAD@Z"]
    pub fn BitStream_PrintHex(this: *const BitStream, out: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}?PrintHex@BitStream@RakNet@@QEBAXXZ"]
    pub fn BitStream_PrintHex1(this: *const BitStream);
}
extern "C" {
    #[doc = " \\brief Ignore data we don't intend to read"]
    #[doc = " \\param[in] numberOfBits The number of bits to ignore"]
    #[link_name = "\u{1}?IgnoreBits@BitStream@RakNet@@QEAAXI@Z"]
    pub fn BitStream_IgnoreBits(this: *mut BitStream, numberOfBits: BitSize_t);
}
extern "C" {
    #[doc = " \\brief Ignore data we don't intend to read"]
    #[doc = " \\param[in] numberOfBits The number of bytes to ignore"]
    #[link_name = "\u{1}?IgnoreBytes@BitStream@RakNet@@QEAAXI@Z"]
    pub fn BitStream_IgnoreBytes(this: *mut BitStream, numberOfBytes: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " \\brief Move the write pointer to a position on the array."]
    #[doc = " \\param[in] offset the offset from the start of the array."]
    #[doc = " \\attention"]
    #[doc = " \\details Dangerous if you don't know what you are doing!"]
    #[doc = " For efficiency reasons you can only write mid-stream if your data is byte aligned."]
    #[link_name = "\u{1}?SetWriteOffset@BitStream@RakNet@@QEAAXI@Z"]
    pub fn BitStream_SetWriteOffset(this: *mut BitStream, offset: BitSize_t);
}
extern "C" {
    #[doc = " \\brief Makes a copy of the internal data for you \\a _data will point to"]
    #[doc = " the stream. Partial bytes are left aligned."]
    #[doc = " \\param[out] _data The allocated copy of GetData()"]
    #[doc = " \\return The length in bits of the stream."]
    #[link_name = "\u{1}?CopyData@BitStream@RakNet@@QEBAIPEAPEAE@Z"]
    pub fn BitStream_CopyData(
        this: *const BitStream,
        _data: *mut *mut ::std::os::raw::c_uchar,
    ) -> BitSize_t;
}
extern "C" {
    #[doc = " \\internal"]
    #[doc = " Set the stream to some initial data."]
    #[link_name = "\u{1}?SetData@BitStream@RakNet@@QEAAXPEAE@Z"]
    pub fn BitStream_SetData(this: *mut BitStream, inByteArray: *mut ::std::os::raw::c_uchar);
}
extern "C" {
    #[doc = " \\brief Write numberToWrite bits from the input source."]
    #[doc = " \\details Right aligned data means in the case of a partial byte, the bits are aligned"]
    #[doc = " from the right (bit 0) rather than the left (as in the normal"]
    #[doc = " internal representation) You would set this to true when"]
    #[doc = " writing user data, and false when copying bitstream data, such"]
    #[doc = " as writing one bitstream to another."]
    #[doc = " \\param[in] inByteArray The data"]
    #[doc = " \\param[in] numberOfBitsToWrite The number of bits to write"]
    #[doc = " \\param[in] rightAlignedBits if true data will be right aligned"]
    #[link_name = "\u{1}?WriteBits@BitStream@RakNet@@QEAAXPEBEI_N@Z"]
    pub fn BitStream_WriteBits(
        this: *mut BitStream,
        inByteArray: *const ::std::os::raw::c_uchar,
        numberOfBitsToWrite: BitSize_t,
        rightAlignedBits: bool,
    );
}
extern "C" {
    #[doc = " \\brief Align the bitstream to the byte boundary and then write the"]
    #[doc = " specified number of bits."]
    #[doc = " \\details This is faster than WriteBits but"]
    #[doc = " wastes the bits to do the alignment and requires you to call"]
    #[doc = " ReadAlignedBits at the corresponding read position."]
    #[doc = " \\param[in] inByteArray The data"]
    #[doc = " \\param[in] numberOfBytesToWrite The size of input."]
    #[link_name = "\u{1}?WriteAlignedBytes@BitStream@RakNet@@QEAAXPEBEI@Z"]
    pub fn BitStream_WriteAlignedBytes(
        this: *mut BitStream,
        inByteArray: *const ::std::os::raw::c_uchar,
        numberOfBytesToWrite: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[link_name = "\u{1}?EndianSwapBytes@BitStream@RakNet@@QEAAXHH@Z"]
    pub fn BitStream_EndianSwapBytes(
        this: *mut BitStream,
        byteOffset: ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " \\brief Aligns the bitstream, writes inputLength, and writes input. Won't write beyond maxBytesToWrite"]
    #[doc = " \\param[in] inByteArray The data"]
    #[doc = " \\param[in] inputLength The size of input."]
    #[doc = " \\param[in] maxBytesToWrite Max bytes to write"]
    #[link_name = "\u{1}?WriteAlignedBytesSafe@BitStream@RakNet@@QEAAXPEBDII@Z"]
    pub fn BitStream_WriteAlignedBytesSafe(
        this: *mut BitStream,
        inByteArray: *const ::std::os::raw::c_char,
        inputLength: ::std::os::raw::c_uint,
        maxBytesToWrite: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " \\brief Read bits, starting at the next aligned bits."]
    #[doc = " \\details Note that the modulus 8 starting offset of the sequence must be the same as"]
    #[doc = " was used with WriteBits. This will be a problem with packet"]
    #[doc = " coalescence unless you byte align the coalesced packets."]
    #[doc = " \\param[in] inOutByteArray The byte array larger than @em numberOfBytesToRead"]
    #[doc = " \\param[in] numberOfBytesToRead The number of byte to read from the internal state"]
    #[doc = " \\return true if there is enough byte."]
    #[link_name = "\u{1}?ReadAlignedBytes@BitStream@RakNet@@QEAA_NPEAEI@Z"]
    pub fn BitStream_ReadAlignedBytes(
        this: *mut BitStream,
        inOutByteArray: *mut ::std::os::raw::c_uchar,
        numberOfBytesToRead: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = " \\brief Reads what was written by WriteAlignedBytesSafe."]
    #[doc = " \\param[in] inOutByteArray The data"]
    #[doc = " \\param[in] maxBytesToRead Maximum number of bytes to read"]
    #[doc = " \\return true on success, false on failure."]
    #[link_name = "\u{1}?ReadAlignedBytesSafe@BitStream@RakNet@@QEAA_NPEADAEAHH@Z"]
    pub fn BitStream_ReadAlignedBytesSafe(
        this: *mut BitStream,
        inOutByteArray: *mut ::std::os::raw::c_char,
        inputLength: *mut ::std::os::raw::c_int,
        maxBytesToRead: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?ReadAlignedBytesSafe@BitStream@RakNet@@QEAA_NPEADAEAII@Z"]
    pub fn BitStream_ReadAlignedBytesSafe1(
        this: *mut BitStream,
        inOutByteArray: *mut ::std::os::raw::c_char,
        inputLength: *mut ::std::os::raw::c_uint,
        maxBytesToRead: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = " \\brief Same as ReadAlignedBytesSafe() but allocates the memory for you using new, rather than assuming it is safe to write to"]
    #[doc = " \\param[in] outByteArray outByteArray will be deleted if it is not a pointer to 0"]
    #[doc = " \\return true on success, false on failure."]
    #[link_name = "\u{1}?ReadAlignedBytesSafeAlloc@BitStream@RakNet@@QEAA_NPEAPEADAEAHI@Z"]
    pub fn BitStream_ReadAlignedBytesSafeAlloc(
        this: *mut BitStream,
        outByteArray: *mut *mut ::std::os::raw::c_char,
        inputLength: *mut ::std::os::raw::c_int,
        maxBytesToRead: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?ReadAlignedBytesSafeAlloc@BitStream@RakNet@@QEAA_NPEAPEADAEAII@Z"]
    pub fn BitStream_ReadAlignedBytesSafeAlloc1(
        this: *mut BitStream,
        outByteArray: *mut *mut ::std::os::raw::c_char,
        inputLength: *mut ::std::os::raw::c_uint,
        maxBytesToRead: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = " \\brief Read \\a numberOfBitsToRead bits to the output source."]
    #[doc = " \\details alignBitsToRight should be set to true to convert internal"]
    #[doc = " bitstream data to userdata. It should be false if you used"]
    #[doc = " WriteBits with rightAlignedBits false"]
    #[doc = " \\param[in] inOutByteArray The resulting bits array"]
    #[doc = " \\param[in] numberOfBitsToRead The number of bits to read"]
    #[doc = " \\param[in] alignBitsToRight if true bits will be right aligned."]
    #[doc = " \\return true if there is enough bits to read"]
    #[link_name = "\u{1}?ReadBits@BitStream@RakNet@@QEAA_NPEAEI_N@Z"]
    pub fn BitStream_ReadBits(
        this: *mut BitStream,
        inOutByteArray: *mut ::std::os::raw::c_uchar,
        numberOfBitsToRead: BitSize_t,
        alignBitsToRight: bool,
    ) -> bool;
}
extern "C" {
    #[doc = " \\brief Write a 0"]
    #[link_name = "\u{1}?Write0@BitStream@RakNet@@QEAAXXZ"]
    pub fn BitStream_Write0(this: *mut BitStream);
}
extern "C" {
    #[doc = " \\brief Write a 1"]
    #[link_name = "\u{1}?Write1@BitStream@RakNet@@QEAAXXZ"]
    pub fn BitStream_Write11(this: *mut BitStream);
}
extern "C" {
    #[doc = " \\brief Reads 1 bit and returns true if that bit is 1 and false if it is 0."]
    #[link_name = "\u{1}?ReadBit@BitStream@RakNet@@QEAA_NXZ"]
    pub fn BitStream_ReadBit(this: *mut BitStream) -> bool;
}
extern "C" {
    #[doc = " \\brief If we used the constructor version with copy data off, this"]
    #[doc = " *makes sure it is set to on and the data pointed to is copied."]
    #[link_name = "\u{1}?AssertCopyData@BitStream@RakNet@@QEAAXXZ"]
    pub fn BitStream_AssertCopyData(this: *mut BitStream);
}
extern "C" {
    #[doc = " \\brief Use this if you pass a pointer copy to the constructor"]
    #[doc = " *(_copyData==false) and want to overallocate to prevent"]
    #[doc = " reallocation."]
    #[link_name = "\u{1}?SetNumberOfBitsAllocated@BitStream@RakNet@@QEAAXI@Z"]
    pub fn BitStream_SetNumberOfBitsAllocated(this: *mut BitStream, lengthInBits: BitSize_t);
}
extern "C" {
    #[doc = " \\brief Reallocates (if necessary) in preparation of writing numberOfBitsToWrite"]
    #[link_name = "\u{1}?AddBitsAndReallocate@BitStream@RakNet@@QEAAXI@Z"]
    pub fn BitStream_AddBitsAndReallocate(this: *mut BitStream, numberOfBitsToWrite: BitSize_t);
}
extern "C" {
    #[doc = " \\internal"]
    #[doc = " \\return How many bits have been allocated internally"]
    #[link_name = "\u{1}?GetNumberOfBitsAllocated@BitStream@RakNet@@QEBAIXZ"]
    pub fn BitStream_GetNumberOfBitsAllocated(this: *const BitStream) -> BitSize_t;
}
extern "C" {
    #[doc = " \\brief Read strings, non reference."]
    #[link_name = "\u{1}?Read@BitStream@RakNet@@QEAA_NPEAD@Z"]
    pub fn BitStream_Read5(this: *mut BitStream, varString: *mut ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?Read@BitStream@RakNet@@QEAA_NPEAE@Z"]
    pub fn BitStream_Read6(this: *mut BitStream, varString: *mut ::std::os::raw::c_uchar) -> bool;
}
extern "C" {
    #[doc = " Write zeros until the bitstream is filled up to \\a bytes"]
    #[link_name = "\u{1}?PadWithZeroToByteLength@BitStream@RakNet@@QEAAXI@Z"]
    pub fn BitStream_PadWithZeroToByteLength(this: *mut BitStream, bytes: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " Get the number of leading zeros for a number"]
    #[doc = " \\param[in] x Number to test"]
    #[link_name = "\u{1}?NumberOfLeadingZeroes@BitStream@RakNet@@SAHE@Z"]
    pub fn BitStream_NumberOfLeadingZeroes(x: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?NumberOfLeadingZeroes@BitStream@RakNet@@SAHG@Z"]
    pub fn BitStream_NumberOfLeadingZeroes1(x: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?NumberOfLeadingZeroes@BitStream@RakNet@@SAHI@Z"]
    pub fn BitStream_NumberOfLeadingZeroes2(x: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?NumberOfLeadingZeroes@BitStream@RakNet@@SAH_K@Z"]
    pub fn BitStream_NumberOfLeadingZeroes3(x: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?NumberOfLeadingZeroes@BitStream@RakNet@@SAHC@Z"]
    pub fn BitStream_NumberOfLeadingZeroes4(x: i8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?NumberOfLeadingZeroes@BitStream@RakNet@@SAHF@Z"]
    pub fn BitStream_NumberOfLeadingZeroes5(x: i16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?NumberOfLeadingZeroes@BitStream@RakNet@@SAHH@Z"]
    pub fn BitStream_NumberOfLeadingZeroes6(x: i32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}?NumberOfLeadingZeroes@BitStream@RakNet@@SAH_J@Z"]
    pub fn BitStream_NumberOfLeadingZeroes7(x: i64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\internal Unrolled inner loop, for when performance is critical"]
    #[link_name = "\u{1}?WriteAlignedVar8@BitStream@RakNet@@QEAAXPEBD@Z"]
    pub fn BitStream_WriteAlignedVar8(
        this: *mut BitStream,
        inByteArray: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " \\internal Unrolled inner loop, for when performance is critical"]
    #[link_name = "\u{1}?ReadAlignedVar8@BitStream@RakNet@@QEAA_NPEAD@Z"]
    pub fn BitStream_ReadAlignedVar8(
        this: *mut BitStream,
        inOutByteArray: *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " \\internal Unrolled inner loop, for when performance is critical"]
    #[link_name = "\u{1}?WriteAlignedVar16@BitStream@RakNet@@QEAAXPEBD@Z"]
    pub fn BitStream_WriteAlignedVar16(
        this: *mut BitStream,
        inByteArray: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " \\internal Unrolled inner loop, for when performance is critical"]
    #[link_name = "\u{1}?ReadAlignedVar16@BitStream@RakNet@@QEAA_NPEAD@Z"]
    pub fn BitStream_ReadAlignedVar16(
        this: *mut BitStream,
        inOutByteArray: *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " \\internal Unrolled inner loop, for when performance is critical"]
    #[link_name = "\u{1}?WriteAlignedVar32@BitStream@RakNet@@QEAAXPEBD@Z"]
    pub fn BitStream_WriteAlignedVar32(
        this: *mut BitStream,
        inByteArray: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " \\internal Unrolled inner loop, for when performance is critical"]
    #[link_name = "\u{1}?ReadAlignedVar32@BitStream@RakNet@@QEAA_NPEAD@Z"]
    pub fn BitStream_ReadAlignedVar32(
        this: *mut BitStream,
        inOutByteArray: *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}?IsNetworkOrderInternal@BitStream@RakNet@@SA_NXZ"]
    pub fn BitStream_IsNetworkOrderInternal() -> bool;
}
extern "C" {
    #[link_name = "\u{1}?ReverseBytes@BitStream@RakNet@@SAXPEAE0I@Z"]
    pub fn BitStream_ReverseBytes(
        inByteArray: *mut ::std::os::raw::c_uchar,
        inOutByteArray: *mut ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[link_name = "\u{1}?ReverseBytesInPlace@BitStream@RakNet@@SAXPEAEI@Z"]
    pub fn BitStream_ReverseBytesInPlace(
        inOutData: *mut ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Default Constructor"]
    #[link_name = "\u{1}??0BitStream@RakNet@@QEAA@XZ"]
    pub fn BitStream_BitStream(this: *mut BitStream);
}
extern "C" {
    #[doc = " \\brief Create the bitstream, with some number of bytes to immediately allocate."]
    #[doc = " \\details There is no benefit to calling this, unless you know exactly how many bytes you need and it is greater than BITSTREAM_STACK_ALLOCATION_SIZE."]
    #[doc = " In that case all it does is save you one or more realloc calls."]
    #[doc = " \\param[in] initialBytesToAllocate the number of bytes to pre-allocate."]
    #[link_name = "\u{1}??0BitStream@RakNet@@QEAA@I@Z"]
    pub fn BitStream_BitStream1(
        this: *mut BitStream,
        initialBytesToAllocate: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " \\brief Initialize the BitStream, immediately setting the data it contains to a predefined pointer."]
    #[doc = " \\details Set \\a _copyData to true if you want to make an internal copy of the data you are passing. Set it to false to just save a pointer to the data."]
    #[doc = " You shouldn't call Write functions with \\a _copyData as false, as this will write to unallocated memory"]
    #[doc = " 99% of the time you will use this function to cast Packet::data to a bitstream for reading, in which case you should write something as follows:"]
    #[doc = " \\code"]
    #[doc = " BitStream bs(packet->data, packet->length, false);"]
    #[doc = " \\endcode"]
    #[doc = " \\param[in] _data An array of bytes."]
    #[doc = " \\param[in] lengthInBytes Size of the \\a _data."]
    #[doc = " \\param[in] _copyData true or false to make a copy of \\a _data or not."]
    #[link_name = "\u{1}??0BitStream@RakNet@@QEAA@PEAEI_N@Z"]
    pub fn BitStream_BitStream2(
        this: *mut BitStream,
        _data: *mut ::std::os::raw::c_uchar,
        lengthInBytes: ::std::os::raw::c_uint,
        _copyData: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}??1BitStream@RakNet@@QEAA@XZ"]
    pub fn BitStream_BitStream_destructor(this: *mut BitStream);
}
impl BitStream {
    #[inline]
    pub unsafe fn GetInstance() -> *mut BitStream {
        BitStream_GetInstance()
    }
    #[inline]
    pub unsafe fn DestroyInstance(i: *mut BitStream) {
        BitStream_DestroyInstance(i)
    }
    #[inline]
    pub unsafe fn Reset(&mut self) {
        BitStream_Reset(self)
    }
    #[inline]
    pub unsafe fn Serialize(
        &mut self,
        writeToBitstream: bool,
        inOutByteArray: *mut ::std::os::raw::c_char,
        numberOfBytes: ::std::os::raw::c_uint,
    ) -> bool {
        BitStream_Serialize(self, writeToBitstream, inOutByteArray, numberOfBytes)
    }
    #[inline]
    pub unsafe fn SerializeFloat16(
        &mut self,
        writeToBitstream: bool,
        inOutFloat: *mut f32,
        floatMin: f32,
        floatMax: f32,
    ) -> bool {
        BitStream_SerializeFloat16(self, writeToBitstream, inOutFloat, floatMin, floatMax)
    }
    #[inline]
    pub unsafe fn SerializeBits(
        &mut self,
        writeToBitstream: bool,
        inOutByteArray: *mut ::std::os::raw::c_uchar,
        numberOfBitsToSerialize: BitSize_t,
        rightAlignedBits: bool,
    ) -> bool {
        BitStream_SerializeBits(
            self,
            writeToBitstream,
            inOutByteArray,
            numberOfBitsToSerialize,
            rightAlignedBits,
        )
    }
    #[inline]
    pub unsafe fn Read(&mut self, bitStream: *mut BitStream, numberOfBits: BitSize_t) -> bool {
        BitStream_Read(self, bitStream, numberOfBits)
    }
    #[inline]
    pub unsafe fn Read1(&mut self, bitStream: *mut BitStream) -> bool {
        BitStream_Read1(self, bitStream)
    }
    #[inline]
    pub unsafe fn Read2(&mut self, bitStream: *mut BitStream, numberOfBits: BitSize_t) -> bool {
        BitStream_Read2(self, bitStream, numberOfBits)
    }
    #[inline]
    pub unsafe fn Read3(&mut self, bitStream: *mut BitStream) -> bool {
        BitStream_Read3(self, bitStream)
    }
    #[inline]
    pub unsafe fn Write(
        &mut self,
        inputByteArray: *const ::std::os::raw::c_char,
        numberOfBytes: ::std::os::raw::c_uint,
    ) {
        BitStream_Write(self, inputByteArray, numberOfBytes)
    }
    #[inline]
    pub unsafe fn Write1(&mut self, bitStream: *mut BitStream, numberOfBits: BitSize_t) {
        BitStream_Write1(self, bitStream, numberOfBits)
    }
    #[inline]
    pub unsafe fn Write2(&mut self, bitStream: *mut BitStream) {
        BitStream_Write2(self, bitStream)
    }
    #[inline]
    pub unsafe fn Write3(&mut self, bitStream: *mut BitStream, numberOfBits: BitSize_t) {
        BitStream_Write3(self, bitStream, numberOfBits)
    }
    #[inline]
    pub unsafe fn Write4(&mut self, bitStream: *mut BitStream) {
        BitStream_Write4(self, bitStream)
    }
    #[inline]
    pub unsafe fn WriteFloat16(&mut self, x: f32, floatMin: f32, floatMax: f32) {
        BitStream_WriteFloat16(self, x, floatMin, floatMax)
    }
    #[inline]
    pub unsafe fn Read4(
        &mut self,
        output: *mut ::std::os::raw::c_char,
        numberOfBytes: ::std::os::raw::c_uint,
    ) -> bool {
        BitStream_Read4(self, output, numberOfBytes)
    }
    #[inline]
    pub unsafe fn ReadFloat16(&mut self, outFloat: *mut f32, floatMin: f32, floatMax: f32) -> bool {
        BitStream_ReadFloat16(self, outFloat, floatMin, floatMax)
    }
    #[inline]
    pub unsafe fn ResetReadPointer(&mut self) {
        BitStream_ResetReadPointer(self)
    }
    #[inline]
    pub unsafe fn ResetWritePointer(&mut self) {
        BitStream_ResetWritePointer(self)
    }
    #[inline]
    pub unsafe fn AssertStreamEmpty(&mut self) {
        BitStream_AssertStreamEmpty(self)
    }
    #[inline]
    pub unsafe fn PrintBits(&self, out: *mut ::std::os::raw::c_char) {
        BitStream_PrintBits(self, out)
    }
    #[inline]
    pub unsafe fn PrintBits1(&self) {
        BitStream_PrintBits1(self)
    }
    #[inline]
    pub unsafe fn PrintHex(&self, out: *mut ::std::os::raw::c_char) {
        BitStream_PrintHex(self, out)
    }
    #[inline]
    pub unsafe fn PrintHex1(&self) {
        BitStream_PrintHex1(self)
    }
    #[inline]
    pub unsafe fn IgnoreBits(&mut self, numberOfBits: BitSize_t) {
        BitStream_IgnoreBits(self, numberOfBits)
    }
    #[inline]
    pub unsafe fn IgnoreBytes(&mut self, numberOfBytes: ::std::os::raw::c_uint) {
        BitStream_IgnoreBytes(self, numberOfBytes)
    }
    #[inline]
    pub unsafe fn SetWriteOffset(&mut self, offset: BitSize_t) {
        BitStream_SetWriteOffset(self, offset)
    }
    #[inline]
    pub unsafe fn CopyData(&self, _data: *mut *mut ::std::os::raw::c_uchar) -> BitSize_t {
        BitStream_CopyData(self, _data)
    }
    #[inline]
    pub unsafe fn SetData(&mut self, inByteArray: *mut ::std::os::raw::c_uchar) {
        BitStream_SetData(self, inByteArray)
    }
    #[inline]
    pub unsafe fn WriteBits(
        &mut self,
        inByteArray: *const ::std::os::raw::c_uchar,
        numberOfBitsToWrite: BitSize_t,
        rightAlignedBits: bool,
    ) {
        BitStream_WriteBits(self, inByteArray, numberOfBitsToWrite, rightAlignedBits)
    }
    #[inline]
    pub unsafe fn WriteAlignedBytes(
        &mut self,
        inByteArray: *const ::std::os::raw::c_uchar,
        numberOfBytesToWrite: ::std::os::raw::c_uint,
    ) {
        BitStream_WriteAlignedBytes(self, inByteArray, numberOfBytesToWrite)
    }
    #[inline]
    pub unsafe fn EndianSwapBytes(
        &mut self,
        byteOffset: ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
    ) {
        BitStream_EndianSwapBytes(self, byteOffset, length)
    }
    #[inline]
    pub unsafe fn WriteAlignedBytesSafe(
        &mut self,
        inByteArray: *const ::std::os::raw::c_char,
        inputLength: ::std::os::raw::c_uint,
        maxBytesToWrite: ::std::os::raw::c_uint,
    ) {
        BitStream_WriteAlignedBytesSafe(self, inByteArray, inputLength, maxBytesToWrite)
    }
    #[inline]
    pub unsafe fn ReadAlignedBytes(
        &mut self,
        inOutByteArray: *mut ::std::os::raw::c_uchar,
        numberOfBytesToRead: ::std::os::raw::c_uint,
    ) -> bool {
        BitStream_ReadAlignedBytes(self, inOutByteArray, numberOfBytesToRead)
    }
    #[inline]
    pub unsafe fn ReadAlignedBytesSafe(
        &mut self,
        inOutByteArray: *mut ::std::os::raw::c_char,
        inputLength: *mut ::std::os::raw::c_int,
        maxBytesToRead: ::std::os::raw::c_int,
    ) -> bool {
        BitStream_ReadAlignedBytesSafe(self, inOutByteArray, inputLength, maxBytesToRead)
    }
    #[inline]
    pub unsafe fn ReadAlignedBytesSafe1(
        &mut self,
        inOutByteArray: *mut ::std::os::raw::c_char,
        inputLength: *mut ::std::os::raw::c_uint,
        maxBytesToRead: ::std::os::raw::c_uint,
    ) -> bool {
        BitStream_ReadAlignedBytesSafe1(self, inOutByteArray, inputLength, maxBytesToRead)
    }
    #[inline]
    pub unsafe fn ReadAlignedBytesSafeAlloc(
        &mut self,
        outByteArray: *mut *mut ::std::os::raw::c_char,
        inputLength: *mut ::std::os::raw::c_int,
        maxBytesToRead: ::std::os::raw::c_uint,
    ) -> bool {
        BitStream_ReadAlignedBytesSafeAlloc(self, outByteArray, inputLength, maxBytesToRead)
    }
    #[inline]
    pub unsafe fn ReadAlignedBytesSafeAlloc1(
        &mut self,
        outByteArray: *mut *mut ::std::os::raw::c_char,
        inputLength: *mut ::std::os::raw::c_uint,
        maxBytesToRead: ::std::os::raw::c_uint,
    ) -> bool {
        BitStream_ReadAlignedBytesSafeAlloc1(self, outByteArray, inputLength, maxBytesToRead)
    }
    #[inline]
    pub unsafe fn ReadBits(
        &mut self,
        inOutByteArray: *mut ::std::os::raw::c_uchar,
        numberOfBitsToRead: BitSize_t,
        alignBitsToRight: bool,
    ) -> bool {
        BitStream_ReadBits(self, inOutByteArray, numberOfBitsToRead, alignBitsToRight)
    }
    #[inline]
    pub unsafe fn WriteBit0(&mut self) {
        BitStream_Write0(self)
    }
    #[inline]
    pub unsafe fn WriteBit1(&mut self) {
        BitStream_Write11(self)
    }
    #[inline]
    pub unsafe fn ReadBit(&mut self) -> bool {
        BitStream_ReadBit(self)
    }
    #[inline]
    pub unsafe fn AssertCopyData(&mut self) {
        BitStream_AssertCopyData(self)
    }
    #[inline]
    pub unsafe fn SetNumberOfBitsAllocated(&mut self, lengthInBits: BitSize_t) {
        BitStream_SetNumberOfBitsAllocated(self, lengthInBits)
    }
    #[inline]
    pub unsafe fn AddBitsAndReallocate(&mut self, numberOfBitsToWrite: BitSize_t) {
        BitStream_AddBitsAndReallocate(self, numberOfBitsToWrite)
    }
    #[inline]
    pub unsafe fn GetNumberOfBitsAllocated(&self) -> BitSize_t {
        BitStream_GetNumberOfBitsAllocated(self)
    }
    #[inline]
    pub unsafe fn Read5(&mut self, varString: *mut ::std::os::raw::c_char) -> bool {
        BitStream_Read5(self, varString)
    }
    #[inline]
    pub unsafe fn Read6(&mut self, varString: *mut ::std::os::raw::c_uchar) -> bool {
        BitStream_Read6(self, varString)
    }
    #[inline]
    pub unsafe fn PadWithZeroToByteLength(&mut self, bytes: ::std::os::raw::c_uint) {
        BitStream_PadWithZeroToByteLength(self, bytes)
    }
    #[inline]
    pub unsafe fn NumberOfLeadingZeroes(x: u8) -> ::std::os::raw::c_int {
        BitStream_NumberOfLeadingZeroes(x)
    }
    #[inline]
    pub unsafe fn NumberOfLeadingZeroes1(x: u16) -> ::std::os::raw::c_int {
        BitStream_NumberOfLeadingZeroes1(x)
    }
    #[inline]
    pub unsafe fn NumberOfLeadingZeroes2(x: u32) -> ::std::os::raw::c_int {
        BitStream_NumberOfLeadingZeroes2(x)
    }
    #[inline]
    pub unsafe fn NumberOfLeadingZeroes3(x: u64) -> ::std::os::raw::c_int {
        BitStream_NumberOfLeadingZeroes3(x)
    }
    #[inline]
    pub unsafe fn NumberOfLeadingZeroes4(x: i8) -> ::std::os::raw::c_int {
        BitStream_NumberOfLeadingZeroes4(x)
    }
    #[inline]
    pub unsafe fn NumberOfLeadingZeroes5(x: i16) -> ::std::os::raw::c_int {
        BitStream_NumberOfLeadingZeroes5(x)
    }
    #[inline]
    pub unsafe fn NumberOfLeadingZeroes6(x: i32) -> ::std::os::raw::c_int {
        BitStream_NumberOfLeadingZeroes6(x)
    }
    #[inline]
    pub unsafe fn NumberOfLeadingZeroes7(x: i64) -> ::std::os::raw::c_int {
        BitStream_NumberOfLeadingZeroes7(x)
    }
    #[inline]
    pub unsafe fn WriteAlignedVar8(&mut self, inByteArray: *const ::std::os::raw::c_char) {
        BitStream_WriteAlignedVar8(self, inByteArray)
    }
    #[inline]
    pub unsafe fn ReadAlignedVar8(&mut self, inOutByteArray: *mut ::std::os::raw::c_char) -> bool {
        BitStream_ReadAlignedVar8(self, inOutByteArray)
    }
    #[inline]
    pub unsafe fn WriteAlignedVar16(&mut self, inByteArray: *const ::std::os::raw::c_char) {
        BitStream_WriteAlignedVar16(self, inByteArray)
    }
    #[inline]
    pub unsafe fn ReadAlignedVar16(&mut self, inOutByteArray: *mut ::std::os::raw::c_char) -> bool {
        BitStream_ReadAlignedVar16(self, inOutByteArray)
    }
    #[inline]
    pub unsafe fn WriteAlignedVar32(&mut self, inByteArray: *const ::std::os::raw::c_char) {
        BitStream_WriteAlignedVar32(self, inByteArray)
    }
    #[inline]
    pub unsafe fn ReadAlignedVar32(&mut self, inOutByteArray: *mut ::std::os::raw::c_char) -> bool {
        BitStream_ReadAlignedVar32(self, inOutByteArray)
    }
    #[inline]
    pub unsafe fn IsNetworkOrderInternal() -> bool {
        BitStream_IsNetworkOrderInternal()
    }
    #[inline]
    pub unsafe fn ReverseBytes(
        inByteArray: *mut ::std::os::raw::c_uchar,
        inOutByteArray: *mut ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_uint,
    ) {
        BitStream_ReverseBytes(inByteArray, inOutByteArray, length)
    }
    #[inline]
    pub unsafe fn ReverseBytesInPlace(
        inOutData: *mut ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_uint,
    ) {
        BitStream_ReverseBytesInPlace(inOutData, length)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        BitStream_BitStream(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(initialBytesToAllocate: ::std::os::raw::c_uint) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        BitStream_BitStream1(&mut __bindgen_tmp, initialBytesToAllocate);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new2(
        _data: *mut ::std::os::raw::c_uchar,
        lengthInBytes: ::std::os::raw::c_uint,
        _copyData: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        BitStream_BitStream2(&mut __bindgen_tmp, _data, lengthInBytes, _copyData);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        BitStream_BitStream_destructor(self)
    }
}
pub type ULONG = ::std::os::raw::c_ulong;
pub type USHORT = ::std::os::raw::c_ushort;
pub type UCHAR = ::std::os::raw::c_uchar;
pub type CHAR = ::std::os::raw::c_char;
#[repr(C)]
pub struct in_addr {
    pub S_un: in_addr__bindgen_ty_1,
}
#[repr(C)]
pub struct in_addr__bindgen_ty_1 {
    pub S_un_b: __BindgenUnionField<in_addr__bindgen_ty_1__bindgen_ty_1>,
    pub S_un_w: __BindgenUnionField<in_addr__bindgen_ty_1__bindgen_ty_2>,
    pub S_addr: __BindgenUnionField<ULONG>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug)]
pub struct in_addr__bindgen_ty_1__bindgen_ty_1 {
    pub s_b1: UCHAR,
    pub s_b2: UCHAR,
    pub s_b3: UCHAR,
    pub s_b4: UCHAR,
}
#[repr(C)]
#[derive(Debug)]
pub struct in_addr__bindgen_ty_1__bindgen_ty_2 {
    pub s_w1: USHORT,
    pub s_w2: USHORT,
}
pub type IN_ADDR = in_addr;
pub type ADDRESS_FAMILY = USHORT;
#[repr(C)]
pub struct sockaddr_in {
    pub sin_family: ADDRESS_FAMILY,
    pub sin_port: USHORT,
    pub sin_addr: IN_ADDR,
    pub sin_zero: [CHAR; 8usize],
}
#[doc = " \\brief Array based implementation of a list."]
#[doc = " \\note ONLY USE THIS FOR SHALLOW COPIES.  I don't bother with operator= to improve performance."]
#[repr(C)]
#[derive(Debug)]
pub struct List<list_type> {
    #[doc = " An array of user values"]
    pub listArray: *mut list_type,
    #[doc = " Number of elements in the list"]
    pub list_size: ::std::os::raw::c_uint,
    #[doc = " Size of \\a array"]
    pub allocation_size: ::std::os::raw::c_uint,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<list_type>>,
}
pub mod OutOfBandIdentifiers {
    pub type Type = i32;
    pub const ID_NAT_ESTABLISH_UNIDIRECTIONAL: Type = 0;
    pub const ID_NAT_ESTABLISH_BIDIRECTIONAL: Type = 1;
    pub const ID_NAT_TYPE_DETECT: Type = 2;
    pub const ID_ROUTER_2_REPLY_TO_SENDER_PORT: Type = 3;
    pub const ID_ROUTER_2_REPLY_TO_SPECIFIED_PORT: Type = 4;
    pub const ID_ROUTER_2_MINI_PUNCH_REPLY: Type = 5;
    pub const ID_ROUTER_2_MINI_PUNCH_REPLY_BOUNCE: Type = 6;
    pub const ID_XBOX_360_VOICE: Type = 7;
    pub const ID_XBOX_360_GET_NETWORK_ROOM: Type = 8;
    pub const ID_XBOX_360_RETURN_NETWORK_ROOM: Type = 9;
    pub const ID_NAT_PING: Type = 10;
    pub const ID_NAT_PONG: Type = 11;
}
pub mod DefaultMessageIDTypes {
    #[doc = " You should not edit the file MessageIdentifiers.h as it is a part of RakNet static library"]
    #[doc = " To define your own message id, define an enum following the code example that follows."]
    #[doc = ""]
    #[doc = " \\code"]
    #[doc = " enum {"]
    #[doc = "   ID_MYPROJECT_MSG_1 = ID_USER_PACKET_ENUM,"]
    #[doc = "   ID_MYPROJECT_MSG_2,"]
    #[doc = "    ..."]
    #[doc = " };"]
    #[doc = " \\endcode"]
    #[doc = ""]
    #[doc = " \\note All these enumerations should be casted to (unsigned char) before writing them to BitStream"]
    pub type Type = i32;
    #[doc = " These types are never returned to the user."]
    #[doc = " Ping from a connected system.  Update timestamps (internal use only)"]
    pub const ID_CONNECTED_PING: Type = 0;
    #[doc = " Ping from an unconnected system.  Reply but do not update timestamps. (internal use only)"]
    pub const ID_UNCONNECTED_PING: Type = 1;
    #[doc = " Ping from an unconnected system.  Only reply if we have open connections. Do not update timestamps. (internal use only)"]
    pub const ID_UNCONNECTED_PING_OPEN_CONNECTIONS: Type = 2;
    #[doc = " Pong from a connected system.  Update timestamps (internal use only)"]
    pub const ID_CONNECTED_PONG: Type = 3;
    #[doc = " A reliable packet to detect lost connections (internal use only)"]
    pub const ID_DETECT_LOST_CONNECTIONS: Type = 4;
    #[doc = " C2S: Initial query: Header(1), OfflineMesageID(16), Protocol number(1), Pad(toMTU), sent with no fragment set."]
    #[doc = " If protocol fails on server, returns ID_INCOMPATIBLE_PROTOCOL_VERSION to client"]
    pub const ID_OPEN_CONNECTION_REQUEST_1: Type = 5;
    #[doc = " S2C: Header(1), OfflineMesageID(16), server GUID(8), HasSecurity(1), Cookie(4, if HasSecurity)"]
    #[doc = " , public key (if do security is true), MTU(2). If public key fails on client, returns ID_PUBLIC_KEY_MISMATCH"]
    pub const ID_OPEN_CONNECTION_REPLY_1: Type = 6;
    #[doc = " C2S: Header(1), OfflineMesageID(16), Cookie(4, if HasSecurity is true on the server), clientSupportsSecurity(1 bit),"]
    #[doc = " handshakeChallenge (if has security on both server and client), remoteBindingAddress(6), MTU(2), client GUID(8)"]
    #[doc = " Connection slot allocated if cookie is valid, server is not full, GUID and IP not already in use."]
    pub const ID_OPEN_CONNECTION_REQUEST_2: Type = 7;
    #[doc = " S2C: Header(1), OfflineMesageID(16), server GUID(8), mtu(2), doSecurity(1 bit), handshakeAnswer (if do security is true)"]
    pub const ID_OPEN_CONNECTION_REPLY_2: Type = 8;
    #[doc = " C2S: Header(1), GUID(8), Timestamp, HasSecurity(1), Proof(32)"]
    pub const ID_CONNECTION_REQUEST: Type = 9;
    #[doc = " RakPeer - Remote system requires secure connections, pass a public key to RakPeerInterface::Connect()"]
    pub const ID_REMOTE_SYSTEM_REQUIRES_PUBLIC_KEY: Type = 10;
    #[doc = " RakPeer - We passed a public key to RakPeerInterface::Connect(), but the other system did not have security turned on"]
    pub const ID_OUR_SYSTEM_REQUIRES_SECURITY: Type = 11;
    #[doc = " RakPeer - Wrong public key passed to RakPeerInterface::Connect()"]
    pub const ID_PUBLIC_KEY_MISMATCH: Type = 12;
    #[doc = " RakPeer - Same as ID_ADVERTISE_SYSTEM, but intended for internal use rather than being passed to the user."]
    #[doc = " Second byte indicates type. Used currently for NAT punchthrough for receiver port advertisement. See ID_NAT_ADVERTISE_RECIPIENT_PORT"]
    pub const ID_OUT_OF_BAND_INTERNAL: Type = 13;
    #[doc = " If RakPeerInterface::Send() is called where PacketReliability contains _WITH_ACK_RECEIPT, then on a later call to"]
    #[doc = " RakPeerInterface::Receive() you will get ID_SND_RECEIPT_ACKED or ID_SND_RECEIPT_LOSS. The message will be 5 bytes long,"]
    #[doc = " and bytes 1-4 inclusive will contain a number in native order containing a number that identifies this message."]
    #[doc = " This number will be returned by RakPeerInterface::Send() or RakPeerInterface::SendList(). ID_SND_RECEIPT_ACKED means that"]
    #[doc = " the message arrived"]
    pub const ID_SND_RECEIPT_ACKED: Type = 14;
    #[doc = " If RakPeerInterface::Send() is called where PacketReliability contains UNRELIABLE_WITH_ACK_RECEIPT, then on a later call to"]
    #[doc = " RakPeerInterface::Receive() you will get ID_SND_RECEIPT_ACKED or ID_SND_RECEIPT_LOSS. The message will be 5 bytes long,"]
    #[doc = " and bytes 1-4 inclusive will contain a number in native order containing a number that identifies this message. This number"]
    #[doc = " will be returned by RakPeerInterface::Send() or RakPeerInterface::SendList(). ID_SND_RECEIPT_LOSS means that an ack for the"]
    #[doc = " message did not arrive (it may or may not have been delivered, probably not). On disconnect or shutdown, you will not get"]
    #[doc = " ID_SND_RECEIPT_LOSS for unsent messages, you should consider those messages as all lost."]
    pub const ID_SND_RECEIPT_LOSS: Type = 15;
    #[doc = " RakPeer - In a client/server environment, our connection request to the server has been accepted."]
    pub const ID_CONNECTION_REQUEST_ACCEPTED: Type = 16;
    #[doc = " RakPeer - Sent to the player when a connection request cannot be completed due to inability to connect."]
    pub const ID_CONNECTION_ATTEMPT_FAILED: Type = 17;
    #[doc = " RakPeer - Sent a connect request to a system we are currently connected to."]
    pub const ID_ALREADY_CONNECTED: Type = 18;
    #[doc = " RakPeer - A remote system has successfully connected."]
    pub const ID_NEW_INCOMING_CONNECTION: Type = 19;
    #[doc = " RakPeer - The system we attempted to connect to is not accepting new connections."]
    pub const ID_NO_FREE_INCOMING_CONNECTIONS: Type = 20;
    #[doc = " RakPeer - The system specified in Packet::systemAddress has disconnected from us.  For the client, this would mean the"]
    #[doc = " server has shutdown."]
    pub const ID_DISCONNECTION_NOTIFICATION: Type = 21;
    #[doc = " RakPeer - Reliable packets cannot be delivered to the system specified in Packet::systemAddress.  The connection to that"]
    #[doc = " system has been closed."]
    pub const ID_CONNECTION_LOST: Type = 22;
    #[doc = " RakPeer - We are banned from the system we attempted to connect to."]
    pub const ID_CONNECTION_BANNED: Type = 23;
    #[doc = " RakPeer - The remote system is using a password and has refused our connection because we did not set the correct password."]
    pub const ID_INVALID_PASSWORD: Type = 24;
    #[doc = " RakPeer - The remote system is using a password and has refused our connection because we did not set the correct password."]
    pub const ID_INCOMPATIBLE_PROTOCOL_VERSION: Type = 25;
    #[doc = " RakPeer::SetLimitIPConnectionFrequency()"]
    pub const ID_IP_RECENTLY_CONNECTED: Type = 26;
    #[doc = " RakPeer - The sizeof(RakNetTime) bytes following this byte represent a value which is automatically modified by the difference"]
    #[doc = " in system times between the sender and the recipient. Requires that you call SetOccasionalPing."]
    pub const ID_TIMESTAMP: Type = 27;
    #[doc = " RakPeer - Pong from an unconnected system.  First byte is ID_UNCONNECTED_PONG, second sizeof(TimeMS) bytes is the ping,"]
    #[doc = " following bytes is system specific enumeration data."]
    #[doc = " Read using bitstreams"]
    pub const ID_UNCONNECTED_PONG: Type = 28;
    #[doc = " RakPeer - Inform a remote system of our IP/Port. On the recipient, all data past ID_ADVERTISE_SYSTEM is whatever was passed to"]
    #[doc = " the data parameter"]
    pub const ID_ADVERTISE_SYSTEM: Type = 29;
    #[doc = "  partTotal (unsigned int),"]
    #[doc = " partLength (unsigned int), first part data (length <= MAX_MTU_SIZE). See the three parameters partCount, partTotal"]
    #[doc = "  and partLength in OnFileProgress in FileListTransferCBInterface.h"]
    pub const ID_DOWNLOAD_PROGRESS: Type = 30;
    #[doc = " ConnectionGraph2 plugin - In a client/server environment, a client other than ourselves has disconnected gracefully."]
    #[doc = "   Packet::systemAddress is modified to reflect the systemAddress of this client."]
    pub const ID_REMOTE_DISCONNECTION_NOTIFICATION: Type = 31;
    #[doc = " ConnectionGraph2 plugin - In a client/server environment, a client other than ourselves has been forcefully dropped."]
    #[doc = "  Packet::systemAddress is modified to reflect the systemAddress of this client."]
    pub const ID_REMOTE_CONNECTION_LOST: Type = 32;
    #[doc = " ConnectionGraph2 plugin: Bytes 1-4 = count. for (count items) contains {SystemAddress, RakNetGUID, 2 byte ping}"]
    pub const ID_REMOTE_NEW_INCOMING_CONNECTION: Type = 33;
    #[doc = " FileListTransfer plugin - Setup data"]
    pub const ID_FILE_LIST_TRANSFER_HEADER: Type = 34;
    #[doc = " FileListTransfer plugin - A file"]
    pub const ID_FILE_LIST_TRANSFER_FILE: Type = 35;
    #[doc = " FileListTransfer plugin - A file"]
    pub const ID_FILE_LIST_REFERENCE_PUSH_ACK: Type = 36;
    #[doc = " DirectoryDeltaTransfer plugin - Request from a remote system for a download of a directory"]
    pub const ID_DDT_DOWNLOAD_REQUEST: Type = 37;
    #[doc = " RakNetTransport plugin - Transport provider message, used for remote console"]
    pub const ID_TRANSPORT_STRING: Type = 38;
    #[doc = " ReplicaManager plugin - Create an object"]
    pub const ID_REPLICA_MANAGER_CONSTRUCTION: Type = 39;
    #[doc = " ReplicaManager plugin - Changed scope of an object"]
    pub const ID_REPLICA_MANAGER_SCOPE_CHANGE: Type = 40;
    #[doc = " ReplicaManager plugin - Serialized data of an object"]
    pub const ID_REPLICA_MANAGER_SERIALIZE: Type = 41;
    #[doc = " ReplicaManager plugin - New connection, about to send all world objects"]
    pub const ID_REPLICA_MANAGER_DOWNLOAD_STARTED: Type = 42;
    #[doc = " ReplicaManager plugin - Finished downloading all serialized objects"]
    pub const ID_REPLICA_MANAGER_DOWNLOAD_COMPLETE: Type = 43;
    #[doc = " RakVoice plugin - Open a communication channel"]
    pub const ID_RAKVOICE_OPEN_CHANNEL_REQUEST: Type = 44;
    #[doc = " RakVoice plugin - Communication channel accepted"]
    pub const ID_RAKVOICE_OPEN_CHANNEL_REPLY: Type = 45;
    #[doc = " RakVoice plugin - Close a communication channel"]
    pub const ID_RAKVOICE_CLOSE_CHANNEL: Type = 46;
    #[doc = " RakVoice plugin - Voice data"]
    pub const ID_RAKVOICE_DATA: Type = 47;
    #[doc = " Autopatcher plugin - Get a list of files that have changed since a certain date"]
    pub const ID_AUTOPATCHER_GET_CHANGELIST_SINCE_DATE: Type = 48;
    #[doc = " Autopatcher plugin - A list of files to create"]
    pub const ID_AUTOPATCHER_CREATION_LIST: Type = 49;
    #[doc = " Autopatcher plugin - A list of files to delete"]
    pub const ID_AUTOPATCHER_DELETION_LIST: Type = 50;
    #[doc = " Autopatcher plugin - A list of files to get patches for"]
    pub const ID_AUTOPATCHER_GET_PATCH: Type = 51;
    #[doc = " Autopatcher plugin - A list of patches for a list of files"]
    pub const ID_AUTOPATCHER_PATCH_LIST: Type = 52;
    #[doc = " Autopatcher plugin - Returned to the user: An error from the database repository for the autopatcher."]
    pub const ID_AUTOPATCHER_REPOSITORY_FATAL_ERROR: Type = 53;
    #[doc = " Autopatcher plugin - Returned to the user: The server does not allow downloading unmodified game files."]
    pub const ID_AUTOPATCHER_CANNOT_DOWNLOAD_ORIGINAL_UNMODIFIED_FILES: Type = 54;
    #[doc = " Autopatcher plugin - Finished getting all files from the autopatcher"]
    pub const ID_AUTOPATCHER_FINISHED_INTERNAL: Type = 55;
    #[doc = " Autopatcher plugin - Finished getting all files from the autopatcher"]
    pub const ID_AUTOPATCHER_FINISHED: Type = 56;
    #[doc = " Autopatcher plugin - Returned to the user: You must restart the application to finish patching."]
    pub const ID_AUTOPATCHER_RESTART_APPLICATION: Type = 57;
    #[doc = " NATPunchthrough plugin: internal"]
    pub const ID_NAT_PUNCHTHROUGH_REQUEST: Type = 58;
    #[doc = " NATPunchthrough plugin: internal"]
    pub const ID_NAT_CONNECT_AT_TIME: Type = 59;
    #[doc = " NATPunchthrough plugin: internal"]
    pub const ID_NAT_GET_MOST_RECENT_PORT: Type = 60;
    #[doc = " NATPunchthrough plugin: internal"]
    pub const ID_NAT_CLIENT_READY: Type = 61;
    #[doc = " NATPunchthrough plugin: Destination system is not connected to the server. Bytes starting at offset 1 contains the"]
    #[doc = "  RakNetGUID destination field of NatPunchthroughClient::OpenNAT()."]
    pub const ID_NAT_TARGET_NOT_CONNECTED: Type = 62;
    #[doc = " NATPunchthrough plugin: Destination system is not responding to ID_NAT_GET_MOST_RECENT_PORT. Possibly the plugin is not installed."]
    #[doc = "  Bytes starting at offset 1 contains the RakNetGUID  destination field of NatPunchthroughClient::OpenNAT()."]
    pub const ID_NAT_TARGET_UNRESPONSIVE: Type = 63;
    #[doc = " NATPunchthrough plugin: The server lost the connection to the destination system while setting up punchthrough."]
    #[doc = "  Possibly the plugin is not installed. Bytes starting at offset 1 contains the RakNetGUID  destination"]
    #[doc = "  field of NatPunchthroughClient::OpenNAT()."]
    pub const ID_NAT_CONNECTION_TO_TARGET_LOST: Type = 64;
    #[doc = " NATPunchthrough plugin: This punchthrough is already in progress. Possibly the plugin is not installed."]
    #[doc = "  Bytes starting at offset 1 contains the RakNetGUID destination field of NatPunchthroughClient::OpenNAT()."]
    pub const ID_NAT_ALREADY_IN_PROGRESS: Type = 65;
    #[doc = " NATPunchthrough plugin: This message is generated on the local system, and does not come from the network."]
    #[doc = "  packet::guid contains the destination field of NatPunchthroughClient::OpenNAT(). Byte 1 contains 1 if you are the sender, 0 if not"]
    pub const ID_NAT_PUNCHTHROUGH_FAILED: Type = 66;
    #[doc = " NATPunchthrough plugin: Punchthrough succeeded. See packet::systemAddress and packet::guid. Byte 1 contains 1 if you are the sender,"]
    #[doc = "  0 if not. You can now use RakPeer::Connect() or other calls to communicate with this system."]
    pub const ID_NAT_PUNCHTHROUGH_SUCCEEDED: Type = 67;
    #[doc = " ReadyEvent plugin - Set the ready state for a particular system"]
    #[doc = " First 4 bytes after the message contains the id"]
    pub const ID_READY_EVENT_SET: Type = 68;
    #[doc = " ReadyEvent plugin - Unset the ready state for a particular system"]
    #[doc = " First 4 bytes after the message contains the id"]
    pub const ID_READY_EVENT_UNSET: Type = 69;
    #[doc = " All systems are in state ID_READY_EVENT_SET"]
    #[doc = " First 4 bytes after the message contains the id"]
    pub const ID_READY_EVENT_ALL_SET: Type = 70;
    #[doc = " \\internal, do not process in your game"]
    #[doc = " ReadyEvent plugin - Request of ready event state - used for pulling data when newly connecting"]
    pub const ID_READY_EVENT_QUERY: Type = 71;
    #[doc = " Lobby packets. Second byte indicates type."]
    pub const ID_LOBBY_GENERAL: Type = 72;
    #[doc = " Lobby packets. Second byte indicates type."]
    pub const ID_RPC_REMOTE_ERROR: Type = 73;
    #[doc = " Plugin based replacement for RPC system"]
    pub const ID_RPC_PLUGIN: Type = 74;
    #[doc = " FileListTransfer transferring large files in chunks that are read only when needed, to save memory"]
    pub const ID_FILE_LIST_REFERENCE_PUSH: Type = 75;
    #[doc = " Force the ready event to all set"]
    pub const ID_READY_EVENT_FORCE_ALL_SET: Type = 76;
    #[doc = " Rooms function"]
    pub const ID_ROOMS_EXECUTE_FUNC: Type = 77;
    #[doc = " Rooms function"]
    pub const ID_ROOMS_LOGON_STATUS: Type = 78;
    #[doc = " Rooms function"]
    pub const ID_ROOMS_HANDLE_CHANGE: Type = 79;
    #[doc = " Lobby2 message"]
    pub const ID_LOBBY2_SEND_MESSAGE: Type = 80;
    #[doc = " Lobby2 message"]
    pub const ID_LOBBY2_SERVER_ERROR: Type = 81;
    #[doc = " Informs user of a new host GUID. Packet::Guid contains this new host RakNetGuid. The old host can be read out using BitStream->Read(RakNetGuid) starting on byte 1"]
    #[doc = " This is not returned until connected to a remote system"]
    #[doc = " If the oldHost is UNASSIGNED_RAKNET_GUID, then this is the first time the host has been determined"]
    pub const ID_FCM2_NEW_HOST: Type = 82;
    #[doc = " \\internal For FullyConnectedMesh2 plugin"]
    pub const ID_FCM2_REQUEST_FCMGUID: Type = 83;
    #[doc = " \\internal For FullyConnectedMesh2 plugin"]
    pub const ID_FCM2_RESPOND_CONNECTION_COUNT: Type = 84;
    #[doc = " \\internal For FullyConnectedMesh2 plugin"]
    pub const ID_FCM2_INFORM_FCMGUID: Type = 85;
    #[doc = " \\internal For FullyConnectedMesh2 plugin"]
    pub const ID_FCM2_UPDATE_MIN_TOTAL_CONNECTION_COUNT: Type = 86;
    #[doc = " A remote system (not necessarily the host) called FullyConnectedMesh2::StartVerifiedJoin() with our system as the client"]
    #[doc = " Use FullyConnectedMesh2::GetVerifiedJoinRequiredProcessingList() to read systems"]
    #[doc = " For each system, attempt NatPunchthroughClient::OpenNAT() and/or RakPeerInterface::Connect()"]
    #[doc = " When this has been done for all systems, the remote system will automatically be informed of the results"]
    #[doc = " \\note Only the designated client gets this message"]
    #[doc = " \\note You won't get this message if you are already connected to all target systems"]
    #[doc = " \\note If you fail to connect to a system, this does not automatically mean you will get ID_FCM2_VERIFIED_JOIN_FAILED as that system may have been shutting down from the host too"]
    #[doc = " \\sa FullyConnectedMesh2::StartVerifiedJoin()"]
    pub const ID_FCM2_VERIFIED_JOIN_START: Type = 87;
    #[doc = " \\internal The client has completed processing for all systems designated in ID_FCM2_VERIFIED_JOIN_START"]
    pub const ID_FCM2_VERIFIED_JOIN_CAPABLE: Type = 88;
    #[doc = " Client failed to connect to a required systems notified via FullyConnectedMesh2::StartVerifiedJoin()"]
    #[doc = " RakPeerInterface::CloseConnection() was automatically called for all systems connected due to ID_FCM2_VERIFIED_JOIN_START"]
    #[doc = " Programmer should inform the player via the UI that they cannot join this session, and to choose a different session"]
    #[doc = " \\note Server normally sends us this message, however if connection to the server was lost, message will be returned locally"]
    #[doc = " \\note Only the designated client gets this message"]
    pub const ID_FCM2_VERIFIED_JOIN_FAILED: Type = 89;
    #[doc = " The system that called StartVerifiedJoin() got ID_FCM2_VERIFIED_JOIN_CAPABLE from the client and then called RespondOnVerifiedJoinCapable() with true"]
    #[doc = " AddParticipant() has automatically been called for this system"]
    #[doc = " Use GetVerifiedJoinAcceptedAdditionalData() to read any additional data passed to RespondOnVerifiedJoinCapable()"]
    #[doc = " \\note All systems in the mesh get this message"]
    #[doc = " \\sa RespondOnVerifiedJoinCapable()"]
    pub const ID_FCM2_VERIFIED_JOIN_ACCEPTED: Type = 90;
    #[doc = " The system that called StartVerifiedJoin() got ID_FCM2_VERIFIED_JOIN_CAPABLE from the client and then called RespondOnVerifiedJoinCapable() with false"]
    #[doc = " CloseConnection() has been automatically called for each system connected to since ID_FCM2_VERIFIED_JOIN_START."]
    #[doc = " The connection is NOT automatically closed to the original host that sent StartVerifiedJoin()"]
    #[doc = " Use GetVerifiedJoinRejectedAdditionalData() to read any additional data passed to RespondOnVerifiedJoinCapable()"]
    #[doc = " \\note Only the designated client gets this message"]
    #[doc = " \\sa RespondOnVerifiedJoinCapable()"]
    pub const ID_FCM2_VERIFIED_JOIN_REJECTED: Type = 91;
    #[doc = " UDP proxy messages. Second byte indicates type."]
    pub const ID_UDP_PROXY_GENERAL: Type = 92;
    #[doc = " SQLite3Plugin - execute"]
    pub const ID_SQLite3_EXEC: Type = 93;
    #[doc = " SQLite3Plugin - Remote database is unknown"]
    pub const ID_SQLite3_UNKNOWN_DB: Type = 94;
    #[doc = " Events happening with SQLiteClientLoggerPlugin"]
    pub const ID_SQLLITE_LOGGER: Type = 95;
    #[doc = " Sent to NatTypeDetectionServer"]
    pub const ID_NAT_TYPE_DETECTION_REQUEST: Type = 96;
    #[doc = " Sent to NatTypeDetectionClient. Byte 1 contains the type of NAT detected."]
    pub const ID_NAT_TYPE_DETECTION_RESULT: Type = 97;
    #[doc = " Used by the router2 plugin"]
    pub const ID_ROUTER_2_INTERNAL: Type = 98;
    #[doc = " No path is available or can be established to the remote system"]
    #[doc = " Packet::guid contains the endpoint guid that we were trying to reach"]
    pub const ID_ROUTER_2_FORWARDING_NO_PATH: Type = 99;
    #[doc = " \\brief You can now call connect, ping, or other operations to the destination system."]
    #[doc = ""]
    #[doc = " Connect as follows:"]
    #[doc = ""]
    #[doc = " BitStream bs(packet->data, packet->length, false);"]
    #[doc = " bs.IgnoreBytes(sizeof(MessageID));"]
    #[doc = " RakNetGUID endpointGuid;"]
    #[doc = " bs.Read(endpointGuid);"]
    #[doc = " unsigned short sourceToDestPort;"]
    #[doc = " bs.Read(sourceToDestPort);"]
    #[doc = " char ipAddressString[32];"]
    #[doc = " packet->systemAddress.ToString(false, ipAddressString);"]
    #[doc = " rakPeerInterface->Connect(ipAddressString, sourceToDestPort, 0,0);"]
    pub const ID_ROUTER_2_FORWARDING_ESTABLISHED: Type = 100;
    #[doc = " The IP address for a forwarded connection has changed"]
    #[doc = " Read endpointGuid and port as per ID_ROUTER_2_FORWARDING_ESTABLISHED"]
    pub const ID_ROUTER_2_REROUTED: Type = 101;
    #[doc = " \\internal Used by the team balancer plugin"]
    pub const ID_TEAM_BALANCER_INTERNAL: Type = 102;
    #[doc = " Cannot switch to the desired team because it is full. However, if someone on that team leaves, you will"]
    #[doc = "  get ID_TEAM_BALANCER_TEAM_ASSIGNED later."]
    #[doc = " For TeamBalancer: Byte 1 contains the team you requested to join. Following bytes contain NetworkID of which member"]
    pub const ID_TEAM_BALANCER_REQUESTED_TEAM_FULL: Type = 103;
    #[doc = " Cannot switch to the desired team because all teams are locked. However, if someone on that team leaves,"]
    #[doc = "  you will get ID_TEAM_BALANCER_SET_TEAM later."]
    #[doc = " For TeamBalancer: Byte 1 contains the team you requested to join."]
    pub const ID_TEAM_BALANCER_REQUESTED_TEAM_LOCKED: Type = 104;
    #[doc = " Cannot switch to the desired team because all teams are locked. However, if someone on that team leaves,"]
    #[doc = "  you will get ID_TEAM_BALANCER_SET_TEAM later."]
    #[doc = " For TeamBalancer: Byte 1 contains the team you requested to join."]
    pub const ID_TEAM_BALANCER_TEAM_REQUESTED_CANCELLED: Type = 105;
    #[doc = " Team balancer plugin informing you of your team. Byte 1 contains the team you requested to join. Following bytes contain NetworkID of which member."]
    pub const ID_TEAM_BALANCER_TEAM_ASSIGNED: Type = 106;
    #[doc = " Gamebryo Lightspeed integration"]
    pub const ID_LIGHTSPEED_INTEGRATION: Type = 107;
    #[doc = " XBOX integration"]
    pub const ID_XBOX_LOBBY: Type = 108;
    #[doc = " The password we used to challenge the other system passed, meaning the other system has called TwoWayAuthentication::AddPassword() with the same password we passed to TwoWayAuthentication::Challenge()"]
    #[doc = " You can read the identifier used to challenge as follows:"]
    #[doc = " BitStream bs(packet->data, packet->length, false); bs.IgnoreBytes(sizeof(MessageID)); RakString password; bs.Read(password);"]
    pub const ID_TWO_WAY_AUTHENTICATION_INCOMING_CHALLENGE_SUCCESS: Type = 109;
    #[doc = " The password we used to challenge the other system passed, meaning the other system has called TwoWayAuthentication::AddPassword() with the same password we passed to TwoWayAuthentication::Challenge()"]
    #[doc = " You can read the identifier used to challenge as follows:"]
    #[doc = " BitStream bs(packet->data, packet->length, false); bs.IgnoreBytes(sizeof(MessageID)); RakString password; bs.Read(password);"]
    pub const ID_TWO_WAY_AUTHENTICATION_OUTGOING_CHALLENGE_SUCCESS: Type = 110;
    #[doc = " A remote system sent us a challenge using TwoWayAuthentication::Challenge(), and the challenge failed."]
    #[doc = " If the other system must pass the challenge to stay connected, you should call RakPeer::CloseConnection() to terminate the connection to the other system."]
    pub const ID_TWO_WAY_AUTHENTICATION_INCOMING_CHALLENGE_FAILURE: Type = 111;
    #[doc = " The other system did not add the password we used to TwoWayAuthentication::AddPassword()"]
    #[doc = " You can read the identifier used to challenge as follows:"]
    #[doc = " BitStream bs(packet->data, packet->length, false); bs.IgnoreBytes(sizeof(MessageID)); RakString password; bs.Read(password);"]
    pub const ID_TWO_WAY_AUTHENTICATION_OUTGOING_CHALLENGE_FAILURE: Type = 112;
    #[doc = " The other system did not respond within a timeout threshhold. Either the other system is not running the plugin or the other system was blocking on some operation for a long time."]
    #[doc = " You can read the identifier used to challenge as follows:"]
    #[doc = " BitStream bs(packet->data, packet->length, false); bs.IgnoreBytes(sizeof(MessageID)); RakString password; bs.Read(password);"]
    pub const ID_TWO_WAY_AUTHENTICATION_OUTGOING_CHALLENGE_TIMEOUT: Type = 113;
    #[doc = " \\internal"]
    pub const ID_TWO_WAY_AUTHENTICATION_NEGOTIATION: Type = 114;
    #[doc = " CloudClient / CloudServer"]
    pub const ID_CLOUD_POST_REQUEST: Type = 115;
    #[doc = " CloudClient / CloudServer"]
    pub const ID_CLOUD_RELEASE_REQUEST: Type = 116;
    #[doc = " CloudClient / CloudServer"]
    pub const ID_CLOUD_GET_REQUEST: Type = 117;
    #[doc = " CloudClient / CloudServer"]
    pub const ID_CLOUD_GET_RESPONSE: Type = 118;
    #[doc = " CloudClient / CloudServer"]
    pub const ID_CLOUD_UNSUBSCRIBE_REQUEST: Type = 119;
    #[doc = " CloudClient / CloudServer"]
    pub const ID_CLOUD_SERVER_TO_SERVER_COMMAND: Type = 120;
    #[doc = " CloudClient / CloudServer"]
    pub const ID_CLOUD_SUBSCRIPTION_NOTIFICATION: Type = 121;
    #[doc = " CloudClient / CloudServer"]
    pub const ID_LIB_VOICE: Type = 122;
    #[doc = " CloudClient / CloudServer"]
    pub const ID_RELAY_PLUGIN: Type = 123;
    #[doc = " CloudClient / CloudServer"]
    pub const ID_NAT_REQUEST_BOUND_ADDRESSES: Type = 124;
    #[doc = " CloudClient / CloudServer"]
    pub const ID_NAT_RESPOND_BOUND_ADDRESSES: Type = 125;
    #[doc = " CloudClient / CloudServer"]
    pub const ID_FCM2_UPDATE_USER_CONTEXT: Type = 126;
    #[doc = " CloudClient / CloudServer"]
    pub const ID_RESERVED_3: Type = 127;
    #[doc = " CloudClient / CloudServer"]
    pub const ID_RESERVED_4: Type = 128;
    #[doc = " CloudClient / CloudServer"]
    pub const ID_RESERVED_5: Type = 129;
    #[doc = " CloudClient / CloudServer"]
    pub const ID_RESERVED_6: Type = 130;
    #[doc = " CloudClient / CloudServer"]
    pub const ID_RESERVED_7: Type = 131;
    #[doc = " CloudClient / CloudServer"]
    pub const ID_RESERVED_8: Type = 132;
    #[doc = " CloudClient / CloudServer"]
    pub const ID_RESERVED_9: Type = 133;
    #[doc = " CloudClient / CloudServer"]
    pub const ID_USER_PACKET_ENUM: Type = 134;
}
